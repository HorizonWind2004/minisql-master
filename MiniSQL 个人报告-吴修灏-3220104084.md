<center><h1>MiniSQL 个人报告</h1></center>

<center>吴修灏，3220104084</center>

## 1. 负责部分

- $\text{Lab 2}$ 的全部模块实现和测试。

- $\text{Lab 4}$ 的全部模块实现和测试。

- $\text{bonus}部分\text{Lab 7}$ 的全部模块实现和测试。

- $\text{Lab 3}$ 的辅助Debug

- $\text{Lab 5}$ 的辅助Debug

## 2. 个人报告

### 2.1 Lab2: Record Manager

#### 2.1.1 Record

- 列（`Column`）:用于定义和表示数据表中的某一个字段，即包含了这个字段的字段名、字段类型、是否唯一等等；
- 模式（`Schema`）:用于表示一个数据表或是一个索引的结构。一个`Schema`由一个或多个的`Column`构成；
- 域（`Field`）:对应于一条记录中某一个字段的数据信息，如存储数据的数据类型，是否是空，存储数据的值等等；
- 行（`Row`）:与元组的概念等价，用于存储记录或索引键，一个`Row`由一个或多个`Field`构成。


**Record对象的持久化存储**

为了持久化存储Record对象，需要提供这些对象与字节流之间相互转化的函数，即序列化和反序列化操作。序列化将内存中的逻辑数据转换成便于在文件中存储的物理数据，反序列化则从存储的物理数据中恢复逻辑数据。

在`Schema`和`Column`对象中引入魔数`MAGIC_NUM`，用于确认反序列化时生成的对象是否符合预期。

- 对于`Column`对象，存储`MAGIC_NUM`、`name_`、`type_`、`len_`（`kTypeChar`类型字段的最大字段长度）、`table_ind`、`nullable_`、`unique_`数据。
- 对于`Schema`对象，存储`MAGIC_NUM`、`column_count`（字段数）、`columns`(各`Column`对象本身存储的数据)、`is_manage_`数据。
- 对于`Field`对象，存储数据值。
- 对于`Row`对象，存储`null_bitmap`、`fields`(对各非空`Field`对象本身存储的数据进行序列化)。

**测试部分**

利用`test/tuple_test`进行测试，未进行额外测试。

**参考代码**

`column.cpp`
```cpp

uint32_t Column::SerializeTo(char *buf) const {
  uint32_t bytes_written=0;
  //write magic number
  MACH_WRITE_UINT32(buf+bytes_written, COLUMN_MAGIC_NUM);
  bytes_written+=sizeof(uint32_t);

  //write column name
  uint32_t name_length=name_.length();
  memcpy(buf+bytes_written,&name_length,sizeof(uint32_t));
  bytes_written+=sizeof(uint32_t);
  memcpy(buf+bytes_written,name_.c_str(),name_length);
  bytes_written+=name_length;
  
  //write type
  MACH_WRITE_TO(TypeId, buf+bytes_written, type_);
  bytes_written+=sizeof(TypeId);

  //write max byte length for kTypeChar
  if(type_==kTypeChar)
  {
    MACH_WRITE_UINT32(buf+bytes_written, len_);
    bytes_written+=sizeof(uint32_t);
  }

  //write index
  MACH_WRITE_UINT32(buf+bytes_written, table_ind_);
  bytes_written+=sizeof(uint32_t);

  //write nullable
  MACH_WRITE_TO(bool, buf+bytes_written, nullable_);
  bytes_written+=sizeof(bool);

  //write unique
  MACH_WRITE_TO(bool, buf+bytes_written, unique_);
  bytes_written+=sizeof(bool);
  return bytes_written;
}

uint32_t Column::GetSerializedSize() const {
  uint32_t written_bytes;
  written_bytes=sizeof(uint32_t) + sizeof(uint32_t)+name_.length() + sizeof(TypeId) + ((type_==kTypeChar)?sizeof(uint32_t):0) + sizeof(uint32_t) + sizeof(bool) + sizeof(bool);
  return written_bytes;
}

uint32_t Column::DeserializeFrom(char *buf, Column *&column) {
   if (column != nullptr) {
    LOG(WARNING) << "Pointer to column is not null in column deserialize."<<std::endl;
    return 0;
  }

  uint32_t bytes_read=0;

  //read magic number
  uint32_t magic_number=MACH_READ_UINT32(buf+bytes_read);
  bytes_read+=sizeof(uint32_t);
  //check magic number
  if(magic_number!=COLUMN_MAGIC_NUM)
  {
    LOG(WARNING) << "column magic number mismatch in column deserialize"<<std::endl;
    return 0;
  }

  //read column name
  uint32_t name_length=MACH_READ_UINT32(buf+bytes_read);
  bytes_read+=sizeof(uint32_t);
  std::string name(buf+bytes_read, buf+bytes_read+name_length);
  bytes_read+=name_length;

  //read type
  TypeId type=MACH_READ_FROM(TypeId, buf+bytes_read);
  bytes_read+=sizeof(TypeId);

  //read max byte length for kTypeChar
  uint32_t len=0;
  if(type==kTypeChar)
  {
    len=MACH_READ_UINT32(buf+bytes_read);
    bytes_read+=sizeof(uint32_t);
  }

  //read index
  uint32_t index=MACH_READ_UINT32(buf+bytes_read);
  bytes_read+=sizeof(uint32_t);

  //read nullable
  bool nullable=MACH_READ_FROM(bool, buf+bytes_read);
  bytes_read+=sizeof(bool);

  //read unique
  bool unique=MACH_READ_FROM(bool, buf+bytes_read);
  bytes_read+=sizeof(bool);

  if(type==kTypeChar)
  {
    column=new Column(name, type, len, index, nullable, unique);
  }
  else
  {
    column=new Column(name, type, index, nullable, unique);
  }

  return bytes_read;
}
```

`Schema.cpp`
```cpp
uint32_t Schema::SerializeTo(char *buf) const {
  uint32_t bytes_written=0;

  //write magic number
  MACH_WRITE_UINT32(buf+bytes_written, SCHEMA_MAGIC_NUM);
  bytes_written+=sizeof(uint32_t);

  //write column count
  uint32_t column_count=GetColumnCount();
  MACH_WRITE_UINT32(buf+bytes_written, column_count);
  bytes_written+=sizeof(uint32_t);

  //write columns
  for(const auto column:columns_)
  {
    bytes_written+=column->SerializeTo(buf+bytes_written);
  }
  
  //write is_manage_
  MACH_WRITE_TO(bool, buf+bytes_written, is_manage_);
  bytes_written+=sizeof(bool);
  return bytes_written;
}

uint32_t Schema::GetSerializedSize() const {
  uint32_t written_size=0;
  
  written_size+=sizeof(uint32_t);
  
  written_size+=sizeof(uint32_t);

  for(const auto column:columns_)
  {

    written_size+=column->GetSerializedSize();
  }

  written_size+=sizeof(bool);

  return written_size;
}

uint32_t Schema::DeserializeFrom(char *buf, Schema *&schema) {
  if (schema != nullptr) {
    LOG(WARNING) << "Pointer to schema is not null in schema deserialize."<<std::endl;
    return 0;
  }

  uint32_t bytes_read=0;

  //read magic number
  uint32_t magic_number=MACH_READ_UINT32(buf+bytes_read);
  bytes_read+=sizeof(uint32_t);
  if(magic_number!=SCHEMA_MAGIC_NUM)
  {
    LOG(WARNING) << "schema magic number mismatch in schema deserialize"<<std::endl;
    return 0;
  }

  //read column count
  uint32_t column_count=MACH_READ_UINT32(buf+bytes_read);
  bytes_read+=sizeof(uint32_t);

  //read columns
  std::vector<Column *>columns;
  columns.reserve(column_count);
  for(uint32_t i=0;i<column_count;++i)
  {
    Column *column=nullptr;
    uint32_t bytes_column_read=Column::DeserializeFrom(buf+bytes_read,column);
    if(!bytes_column_read)//Failed to deserialize column
    {
      for(auto col:columns)
      {
        delete col;
      }
      LOG(WARNING)<<"column deserialize failed in schema deserialize"<<std::endl;
      return 0;
    }
    columns.push_back(column);
    bytes_read+=bytes_column_read;
  }

  //read is_manage_
  bool is_manage=MACH_READ_FROM(bool, buf+bytes_read);
  bytes_read+=sizeof(bool);

  schema=new Schema(columns, is_manage);
  return bytes_read;
}
```

`row.cpp`
```cpp
uint32_t Row::SerializeTo(char *buf, Schema *schema) const {
  ASSERT(schema != nullptr, "Invalid schema before serialize.");
  ASSERT(schema->GetColumnCount() == fields_.size(), "Fields size do not match schema's column size.");

  uint32_t bytes_written=0;

  uint32_t field_count=GetFieldCount();

  //write null bitmap
  uint8_t null_bitmap[(field_count+7)/8];
  memset(null_bitmap,0,sizeof(null_bitmap));
  for(uint32_t i=0;i<field_count;++i)
  {
    if(fields_[i]->IsNull())
    {
      null_bitmap[i/8]|=(1<<(i%8));
    }
  }
  for(int i=0;i<(field_count+7)/8;++i)
  {
    MACH_WRITE_TO(uint8_t,buf+bytes_written,null_bitmap[i]);
    bytes_written+=sizeof(uint8_t);
  }

  //write field
  for(uint32_t i=0;i<field_count;++i)
  {
    if(fields_[i]->IsNull())continue;
    bytes_written+=fields_[i]->SerializeTo(buf+bytes_written);
  }
  return bytes_written;
}

uint32_t Row::DeserializeFrom(char *buf, Schema *schema) {
  ASSERT(schema != nullptr, "Invalid schema before serialize.");
  ASSERT(fields_.empty(), "Non empty field in row.");

  uint32_t bytes_read=0;

  uint32_t field_count=schema->GetColumnCount();

  //read null bitmap
  bool null_bitmap[(field_count+7)/8];
  for(int i=0;i<(field_count+7)/8;++i)
  {
    null_bitmap[i]=MACH_READ_FROM(uint8_t,buf+bytes_read);
    bytes_read+=sizeof(uint8_t);
  }

  for(uint32_t i=0;i<field_count;++i)
  {
    Field *field=nullptr;
    if(null_bitmap[i/8]&(1<<(i%8)))
    {
      field=new Field(schema->GetColumn(i)->GetType());
    }
    else
    {
      bytes_read+=Field::DeserializeFrom(buf+bytes_read,schema->GetColumn(i)->GetType(),&field,null_bitmap[i]);
    }
    fields_.push_back(field);
  }
  return bytes_read;
}

uint32_t Row::GetSerializedSize(Schema *schema) const {
  ASSERT(schema != nullptr, "Invalid schema before serialize.");
  ASSERT(schema->GetColumnCount() == fields_.size(), "Fields size do not match schema's column size.");
  uint32_t written_size=0;

  uint32_t field_count=fields_.size();

  written_size+=((field_count+7)/8)*sizeof(uint8_t);

  for(uint32_t i=0;i<field_count;++i)
  {
    if(fields_[i]->IsNull())continue;
    written_size+=fields_[i]->GetSerializedSize();
  }

  return written_size;
}
```

#### 2.1.2 TableHeap

堆表(`TableHeap`)是一种将记录以无序堆的形式进行组织的数据结构，由多个数据页（`TablePage`）构成，`TablePage`之间通过双向链表链接（`PrevPageId,NextPageId`）。`RowId`记录了该记录所在的`page_id`和`slot_num`，即所在的数据页和偏移。

每个数据也页由表头(`Table Page Header`)、空闲空间（`Free Space`）和已插入数据(`Inserted Tuples`)三部分组成。表头记录`PrevPageId, NextPageId, FreeSpacePointer`以及每条记录在当前数据页中的偏移和长度。

为实现`TableHeap`，需要完成如下功能

- 对于构造函数，申请一个空白数据页，并将`first_page_id`指向该数据页
- 对于`InsertTuple`操作，先判断序列化的大小是否超过一整个数据页可以放下的大小，如果序列化大小过大则直接返回`false`,表示插入失败。之后，我们遍历`TableHeap`中的每一个数据页，查看当前数据页是否可以放下这个`Tuple`，如果其中有一个数据页成功放下，返回`True`。否则，新建数据页，在其中放入`Tuple`，并将此数据页添加到`TableHeap`中。
- 对于`MarkDelete`, `ApplyDelete`, `RollbackDelete`,`GetTuple`操作，通过输入的`rid`获取对应的数据页，再执行数据页中实现的对应函数即可。
- 对于`UpdateTuple`操作，先尝试是否能在原位置执行更新，如果可以，返回`True`;否则，使用`InsertTuple`在`TableHeap`中插入更新后的数据，再`MarkDelete`原位置的数据。
- `Begin`函数遍历数据页，获取第一个存放`Tuple`的rid，并以`TableIterator`的格式返回。如果始终未找到，返回`End`。
- `End`函数返回`TableIterator`格式的`INVALID_ROWID`。
- 自行在框架中添加`GetNextTupleRid`函数，输入一条记录，利用其`rid`遍历后面的数据页，得到下一条记录的`rid`。

**参考代码**

```cpp
bool TableHeap::InsertTuple(Row &row, Txn *txn) {
  uint32_t serialized_size=row.GetSerializedSize(schema_);
  if(serialized_size>=TablePage::SIZE_MAX_ROW)return 0;
  page_id_t cur_page_id=first_page_id_,prev_page_id=INVALID_PAGE_ID;
  TablePage *page=reinterpret_cast<TablePage *>(buffer_pool_manager_->FetchPage(cur_page_id));
  if(page==nullptr)return 0;
  page->WLatch();
  bool p;
  while(!(p=page->InsertTuple(row,schema_,txn,lock_manager_,log_manager_)))
  {
    page->WUnlatch();
    buffer_pool_manager_->UnpinPage(cur_page_id,0);
    prev_page_id=cur_page_id;
    cur_page_id=page->GetNextPageId();
    if(cur_page_id==INVALID_PAGE_ID)break;
    page=reinterpret_cast<TablePage *>(buffer_pool_manager_->FetchPage(page->GetNextPageId()));
    if(page==nullptr)break;
    page->WLatch();
  }
  if(p)
  {
    page->WUnlatch();
    buffer_pool_manager_->UnpinPage(cur_page_id,1);
    return 1;
  }
  page=reinterpret_cast<TablePage *>(buffer_pool_manager_->NewPage(cur_page_id));
  if(page==nullptr)return 0;
  page->Init(cur_page_id,prev_page_id, log_manager_,txn);
  page->WLatch();
  page->InsertTuple(row,schema_,txn,lock_manager_,log_manager_);
  page->WUnlatch();
  buffer_pool_manager_->UnpinPage(cur_page_id,1);

  page=reinterpret_cast<TablePage *>(buffer_pool_manager_->FetchPage(prev_page_id));
  page->WLatch();
  page->SetNextPageId(cur_page_id);
  page->WUnlatch();
  buffer_pool_manager_->UnpinPage(prev_page_id,1);
  return 1;
}

bool TableHeap::MarkDelete(const RowId &rid, Txn *txn) {
  // Find the page which contains the tuple.
  auto page = reinterpret_cast<TablePage *>(buffer_pool_manager_->FetchPage(rid.GetPageId()));
  // If the page could not be found, then abort the recovery.
  if (page == nullptr) {
    return false;
  }
  // Otherwise, mark the tuple as deleted.
  page->WLatch();
  page->MarkDelete(rid, txn, lock_manager_, log_manager_);
  page->WUnlatch();
  buffer_pool_manager_->UnpinPage(page->GetTablePageId(), true);

  return true;
}

bool TableHeap::UpdateTuple(Row &row, const RowId &rid, Txn *txn) {
  row.SetRowId(rid);
  auto page = reinterpret_cast<TablePage *>(buffer_pool_manager_->FetchPage(rid.GetPageId()));
  if(!page)return 0;
  Row old_row(rid);
  page->WLatch();
  bool is_succeeded=page->UpdateTuple(row, &old_row, schema_, txn, lock_manager_, log_manager_);
  page->WUnlatch();
  if(is_succeeded)
  {
    buffer_pool_manager_->UnpinPage(rid.GetPageId(),true);
    return true;
  }
  else
  {
    buffer_pool_manager_->UnpinPage(rid.GetPageId(),false);
    if(InsertTuple(row,txn))
    {
      MarkDelete(rid,txn);
      return true;
    }
  }
  return is_succeeded;
}

void TableHeap::ApplyDelete(const RowId &rid, Txn *txn) {
  // Step1: Find the page which contains the tuple.
  auto page=reinterpret_cast<TablePage *>(buffer_pool_manager_->FetchPage(rid.GetPageId()));
  if(!page)
  {
    LOG(WARNING) << "Failed to get page in ApplyDelete"<<std::endl;
    return;
  }
  // Step2: Delete the tuple from the page.
  page->WLatch();
  page->ApplyDelete(rid, txn, log_manager_);
  page->WUnlatch();
  buffer_pool_manager_->UnpinPage(rid.GetPageId(),true);
}

void TableHeap::RollbackDelete(const RowId &rid, Txn *txn) {
  // Find the page which contains the tuple.
  auto page = reinterpret_cast<TablePage *>(buffer_pool_manager_->FetchPage(rid.GetPageId()));
  assert(page != nullptr);
  // Rollback to delete.
  page->WLatch();
  page->RollbackDelete(rid, txn, log_manager_);
  page->WUnlatch();
  buffer_pool_manager_->UnpinPage(page->GetTablePageId(), true);
}

bool TableHeap::GetTuple(Row *row, Txn *txn) {
  auto page=reinterpret_cast<TablePage *>(buffer_pool_manager_->FetchPage(row->GetRowId().GetPageId()));
  if(!page)return 0;
  page->RLatch();
  row->destroy();
  bool is_found=page->GetTuple(row,schema_, txn, lock_manager_);
  page->RUnlatch();
  buffer_pool_manager_->UnpinPage(row->GetRowId().GetPageId(),false);
  return is_found;
}

bool TableHeap::GetNextTupleRid(const RowId &rid, RowId *nxt_rid, Txn *txn)
{
  page_id_t cur_page_id=rid.GetPageId();
  TablePage *page=reinterpret_cast<TablePage *>(buffer_pool_manager_->FetchPage(cur_page_id));
  if(!page)
  {
    return 0;
  }
  page->RLatch();
  bool is_found=page->GetNextTupleRid(rid, nxt_rid);
  while(!is_found)
  {
    page_id_t nxt_page_id=page->GetNextPageId();
    page->RUnlatch();
    buffer_pool_manager_->UnpinPage(cur_page_id,false);
    if(nxt_page_id==INVALID_PAGE_ID)
    {
      return 0;
    }
    cur_page_id=nxt_page_id;
    page=reinterpret_cast<TablePage *>(buffer_pool_manager_->FetchPage(cur_page_id));
    if(!page)
    {
      return 0;
    }
    page->RLatch();
    is_found=page->GetFirstTupleRid(nxt_rid);
  }
  page->RUnlatch();
  buffer_pool_manager_->UnpinPage(cur_page_id, false);
  return 1;
}

void TableHeap::DeleteTable(page_id_t page_id) {
  if (page_id != INVALID_PAGE_ID) {
    auto temp_table_page = reinterpret_cast<TablePage *>(buffer_pool_manager_->FetchPage(page_id));  // 删除table_heap
    if (temp_table_page->GetNextPageId() != INVALID_PAGE_ID)
      DeleteTable(temp_table_page->GetNextPageId());
    buffer_pool_manager_->UnpinPage(page_id, false);
    buffer_pool_manager_->DeletePage(page_id);
  } else {
    DeleteTable(first_page_id_);
  }
}

TableIterator TableHeap::Begin(Txn *txn) {
  page_id_t cur_page_id=GetFirstPageId();
  while(cur_page_id!=INVALID_PAGE_ID)
  {
    TablePage *page=reinterpret_cast<TablePage *>(buffer_pool_manager_->FetchPage(cur_page_id));
    if(!page)
    {
      LOG(WARNING) << "Failed to get page in ApplyDelete"<<std::endl;
      return End();
    }
    page->RLatch();
    RowId first_rid;
    bool is_found=page->GetFirstTupleRid(&first_rid);
    if(is_found)
    {
      TableIterator first_iterator(this, first_rid, txn);
      page->RUnlatch();
      buffer_pool_manager_->UnpinPage(cur_page_id,false);
      return TableIterator(first_iterator);
    }
    page_id_t nxt_page_id=page->GetNextPageId();
    page->RUnlatch();
    buffer_pool_manager_->UnpinPage(cur_page_id, false);
    cur_page_id=nxt_page_id;
  }
  return End();
}

TableIterator TableHeap::End() { return TableIterator(nullptr, RowId(INVALID_PAGE_ID, 0), nullptr); }
```
#### 2.1.3 TableIterator

从`TableHeap`的第一条记录开始，依次遍历所有记录

TableIterator中存放对应的`TableHeap`，当前记录的`row`和`rid`,以及对应的事务`txn`。

- 带参数构造和拷贝构造中，创建一个新的`Row*`对象指向对应的`rid`
- 析构中，删除对应的`Row*`指针
- `==`和`!=`运算符重载中，判断两个`TableIterator`对象相等的依据是两者的`TableHeap`相同、`rid`相同或共同指向`INVALID_PAGE_ID`。
- 对于`*`和`->`运算符重载，返回对应的`Row`或`Row*`成员变量。
- 对于`=`运算符重载，将当前`TableIterator`的成员变量赋值为传入的变量。
- 对于`iter++`和`++iter`操作，利用`TableHeap`中实现的`GetNextTupleRid`函数找到下一个元组所在的位置，并指向那一个元组。如果始终未找到，返回`TableHeap::End()`。

**测试部分**

和`TableHeap`一同在`table_heap_test.cpp`中进行测试。然而，原测试仅测试了`InsertTuple`、`GetTuple`和迭代器相关的部分。添加对于`UpdataTuple`和`Delete`相关功能的测试

测试代码如下：
```cpp
static string db_file_name = "table_heap_test.db";
using Fields = std::vector<Field>;

TEST(TableHeapTest, TableHeapSampleTest) {
  // init testing instance
  remove(db_file_name.c_str());
  auto disk_mgr_ = new DiskManager(db_file_name);
  auto bpm_ = new BufferPoolManager(DEFAULT_BUFFER_POOL_SIZE, disk_mgr_);
  const int row_nums = 10000;
  // create schema
  std::vector<Column *> columns = {new Column("id", TypeId::kTypeInt, 0, false, false),
                                   new Column("name", TypeId::kTypeChar, 64, 1, true, false),
                                   new Column("account", TypeId::kTypeFloat, 2, true, false)};
  auto schema = std::make_shared<Schema>(columns);
  // create rows
  std::unordered_map<int64_t, Fields *> row_values;
  
  RowId row_ids[row_nums];

  uint32_t size = 0;
  TableHeap *table_heap = TableHeap::Create(bpm_, schema.get(), nullptr, nullptr, nullptr);
  for (int i = 0; i < row_nums; i++) {
    int32_t len = RandomUtils::RandomInt(0, 64);
    char *characters = new char[len];
    RandomUtils::RandomString(characters, len);
    Fields *fields =
        new Fields{Field(TypeId::kTypeInt, i), Field(TypeId::kTypeChar, const_cast<char *>(characters), len, true),
                   Field(TypeId::kTypeFloat, RandomUtils::RandomFloat(-999.f, 999.f))};
    Row row(*fields);
    ASSERT_TRUE(table_heap->InsertTuple(row, nullptr));
    if (row_values.find(row.GetRowId().Get()) != row_values.end()) {
      std::cout << row.GetRowId().Get() << std::endl;
      ASSERT_TRUE(false);
    } else {
      row_values.emplace(row.GetRowId().Get(), fields);
      row_ids[i]=row.GetRowId();
      size++;
    }
    delete[] characters;
  }

  ASSERT_EQ(row_nums, row_values.size());
  ASSERT_EQ(row_nums, size);

  std::unordered_map<int64_t, Fields *> row_values2;
  for (auto row_kv : row_values) {
    size--;
    Row row(RowId(row_kv.first));
    table_heap->GetTuple(&row, nullptr);
    ASSERT_EQ(schema.get()->GetColumnCount(), row.GetFields().size());
    for (size_t j = 0; j < schema.get()->GetColumnCount(); j++) {
      ASSERT_EQ(CmpBool::kTrue, row.GetField(j)->CompareEquals(row_kv.second->at(j)));
    }
    // free spaces
    delete row_kv.second;
  }
  ASSERT_EQ(size, 0);

  int count=0;
  for(int i=0;i<row_nums;++i)
  {
    int32_t len = RandomUtils::RandomInt(0, 64);
    char *characters = new char[len];
    RandomUtils::RandomString(characters, len);
    Fields *fields =
        new Fields{Field(TypeId::kTypeInt, i), Field(TypeId::kTypeChar, const_cast<char *>(characters), len, true),
                   Field(TypeId::kTypeFloat, RandomUtils::RandomFloat(-999.f, 999.f))};
    Row row(*fields);
    ASSERT_EQ(true, table_heap->UpdateTuple(row,row_ids[i],nullptr));
    ASSERT_EQ(false, row.GetRowId().GetPageId()==INVALID_PAGE_ID);
    row_values2.emplace(row.GetRowId().Get(),fields);
    delete[] characters;
    ++count;
  }
  ASSERT_EQ(true, count==row_nums);

  for(auto row_kv:row_values2)
  {
    Row row(RowId(row_kv.first));
    table_heap->GetTuple(&row, nullptr);
    ASSERT_EQ(schema.get()->GetColumnCount(), row.GetFields().size());
    for (size_t j = 0; j < schema.get()->GetColumnCount(); j++) {
      ASSERT_EQ(CmpBool::kTrue, row.GetField(j)->CompareEquals(row_kv.second->at(j)));
    }
    table_heap->ApplyDelete(row.GetRowId(),nullptr);
    ASSERT_EQ(false, table_heap->GetTuple(&row, nullptr));
    count--;
  }
  ASSERT_EQ(0,count);
}

```

**参考代码**

```cpp
TableIterator::TableIterator(TableHeap *table_heap, RowId rid, Txn *txn):table_heap_(table_heap),rid_(rid),txn_(txn),cur_row_(nullptr) {
  cur_row_=new Row(rid);
  if(table_heap!=nullptr)
  {
    table_heap->GetTuple(cur_row_, txn);
  }
}

TableIterator::TableIterator(const TableIterator &other):table_heap_(other.table_heap_),rid_(other.rid_),txn_(other.txn_),cur_row_(nullptr) {
    cur_row_=new Row(rid_);
    if(other.cur_row_!=nullptr)
    {
      *cur_row_=*other.cur_row_;
    }
}

TableIterator::~TableIterator() {
  delete cur_row_;
}

bool TableIterator::operator==(const TableIterator &itr) const {
  return (table_heap_==itr.table_heap_)&&((rid_.GetPageId()==INVALID_PAGE_ID&&itr.rid_.GetPageId()==INVALID_PAGE_ID)||rid_==itr.rid_);
}

bool TableIterator::operator!=(const TableIterator &itr) const {
  return !(*this==itr);
}

const Row &TableIterator::operator*() {
  ASSERT(cur_row_!=nullptr,"Dereferencing a null iterator");
  return *cur_row_;
}

Row *TableIterator::operator->() {
  ASSERT(cur_row_!=nullptr, "Accessing a null iterator");
  return cur_row_;
}

TableIterator &TableIterator::operator=(const TableIterator &itr) noexcept {
  if(this!=&itr)
  {
    table_heap_=itr.table_heap_;
    rid_=itr.rid_;
    txn_=itr.txn_;
    cur_row_->SetRowId(rid_);
    if(itr.cur_row_!=nullptr)*cur_row_=*itr.cur_row_;
  }
  return *this;
}

// ++iter
TableIterator &TableIterator::operator++() {
  ASSERT(cur_row_!=nullptr, "Incrementing a null iterator");
  RowId nxt_rid;
  if(table_heap_->GetNextTupleRid(rid_, &nxt_rid, txn_))
  {
    rid_=nxt_rid;
    cur_row_->SetRowId(rid_);
    if(table_heap_!=nullptr)table_heap_->GetTuple(cur_row_,txn_);
  }
  else
  {
    *this=TableIterator(nullptr, RowId(INVALID_PAGE_ID, 0), nullptr);
  }
  return *this;
}

// iter++
TableIterator TableIterator::operator++(int) {
  TableIterator tmp=TableIterator(*this);
  ++(*this);
  return TableIterator(tmp);
}
```


### 2.2 Lab4: Catalog Manager

负责管理和维护数据库中的所有模式信息（元信息），包括：
- 数据库中所有表的定义信息，包括表的名称、表中字段数、主键、定义在表上的索引。
- 表中每个字段的定义信息，包括字段类型、是否唯一等。
- 数据库中所有索引的定义，包括所属表，索引建立在哪一个字段上等。

还需要为执行器Executor提供公共接口以供执行器获取目录信息并生成执行计划

#### 2.2.1 元信息的持久化

表和索引以`TableInfo`和`IndexInfo`的逻辑数据形式展现。其中IndexInfo包含索引定义时的元信息`meta_data_`，索引对应的表信息`table_info`，索引的模式信息`key_schema_`和索引操作对象`index_`。除了`meta_data_`外，其它信息都是通过反序列化后的元信息生成的。

为简便处理，在序列化时，对于每一个表和索引都单独分配一个数据页用于存储序列化数据。因此，需要一个数据页和数据对象`CatalogMeta`来记录和管理每一个表和索引的元信息被存储在哪一个数据页中。`CatalogMeta`本身的信息会被序列化到`CATALOG_META_PAGE_ID`号数据页上。

- `CatalogMeta`的序列化：对`MAGIC_NUM`、`table_meta_pages`、`index_meta_pages`的相关数据进行序列化。
- `IndexMetadata`的序列化：对`MAGIC_NUM`、`index_id_`、`index_name_`、`table_id_`、`key_map`对应的相关数据进行序列化。
- `TableMetadata`的序列化：对`MAGIC_NUM`、`table_id_`、`table_name_`、`root_page_id_`、`schema_`数据进行序列化 
- `IndexInfo`的初始化：初始化`meta_data_`、`table_info`，然后利用`table_info`中的`schema`和`meta_data`中的`key mapping`得到`index`对应的`key schema`，最后建立`index`索引。

**参考代码**

`CatalogMeta`序列化：
```cpp

void CatalogMeta::SerializeTo(char *buf) const {
  ASSERT(GetSerializedSize() <= PAGE_SIZE, "Failed to serialize catalog metadata to disk.");
  MACH_WRITE_UINT32(buf, CATALOG_METADATA_MAGIC_NUM);
  buf += 4;
  MACH_WRITE_UINT32(buf, table_meta_pages_.size());
  buf += 4;
  MACH_WRITE_UINT32(buf, index_meta_pages_.size());
  buf += 4;
  for (auto iter : table_meta_pages_) {
    MACH_WRITE_TO(table_id_t, buf, iter.first);
    buf += 4;
    MACH_WRITE_TO(page_id_t, buf, iter.second);
    buf += 4;
  }
  for (auto iter : index_meta_pages_) {
    MACH_WRITE_TO(index_id_t, buf, iter.first);
    buf += 4;
    MACH_WRITE_TO(page_id_t, buf, iter.second);
    buf += 4;
  }
}

CatalogMeta *CatalogMeta::DeserializeFrom(char *buf) {
  // check valid
  uint32_t magic_num = MACH_READ_UINT32(buf);
  buf += 4;
  ASSERT(magic_num == CATALOG_METADATA_MAGIC_NUM, "Failed to deserialize catalog metadata from disk.");
  // get table and index nums
  uint32_t table_nums = MACH_READ_UINT32(buf);
  buf += 4;
  uint32_t index_nums = MACH_READ_UINT32(buf);
  buf += 4;
  // create metadata and read value
  CatalogMeta *meta = new CatalogMeta();
  for (uint32_t i = 0; i < table_nums; i++) {
    auto table_id = MACH_READ_FROM(table_id_t, buf);
    buf += 4;
    auto table_heap_page_id = MACH_READ_FROM(page_id_t, buf);
    buf += 4;
    meta->table_meta_pages_.emplace(table_id, table_heap_page_id);
  }
  for (uint32_t i = 0; i < index_nums; i++) {
    auto index_id = MACH_READ_FROM(index_id_t, buf);
    buf += 4;
    auto index_page_id = MACH_READ_FROM(page_id_t, buf);
    buf += 4;
    meta->index_meta_pages_.emplace(index_id, index_page_id);
  }
  return meta;
}

uint32_t CatalogMeta::GetSerializedSize() const {
  uint32_t buf=0;
  buf += 4;
  buf += 4;
  buf += 4;
  for (auto iter : table_meta_pages_) {
    buf += 4;
    buf += 4;
  }
  for (auto iter : index_meta_pages_) {
    buf += 4;
    buf += 4;
  }
  return buf;
}
```
`IndexMetadata`的序列化：
```cpp
uint32_t IndexMetadata::SerializeTo(char *buf) const {
  char *p = buf;
  uint32_t ofs = GetSerializedSize();
  ASSERT(ofs <= PAGE_SIZE, "Failed to serialize index info.");
  // magic num
  MACH_WRITE_UINT32(buf, INDEX_METADATA_MAGIC_NUM);
  buf += 4;
  // index id
  MACH_WRITE_TO(index_id_t, buf, index_id_);
  buf += 4;
  // index name
  MACH_WRITE_UINT32(buf, index_name_.length());
  buf += 4;
  MACH_WRITE_STRING(buf, index_name_);
  buf += index_name_.length();
  // table id
  MACH_WRITE_TO(table_id_t, buf, table_id_);
  buf += 4;
  // key count
  MACH_WRITE_UINT32(buf, key_map_.size());
  buf += 4;
  // key mapping in table
  for (auto &col_index : key_map_) {
    MACH_WRITE_UINT32(buf, col_index);
    buf += 4;
  }
  ASSERT(buf - p == ofs, "Unexpected serialize size.");
  return ofs;
}

/**
 * TODO: Student Implement
 */
uint32_t IndexMetadata::GetSerializedSize() const {
  uint32_t buf=0;
  buf += 4;
  // index id
  buf += 4;
  // index name
  buf += 4;
  buf += index_name_.length();
  // table id
  buf += 4;
  // key count
  buf += 4;
  // key mapping in table
  for (auto &col_index : key_map_) {
    buf += 4;
  }
  return buf;
}

uint32_t IndexMetadata::DeserializeFrom(char *buf, IndexMetadata *&index_meta) {
  if (index_meta != nullptr) {
    LOG(WARNING) << "Pointer object index info is not null in table info deserialize." << std::endl;
  }
  char *p = buf;
  // magic num
  uint32_t magic_num = MACH_READ_UINT32(buf);
  buf += 4;
  ASSERT(magic_num == INDEX_METADATA_MAGIC_NUM, "Failed to deserialize index info.");
  // index id
  index_id_t index_id = MACH_READ_FROM(index_id_t, buf);
  buf += 4;
  // index name
  uint32_t len = MACH_READ_UINT32(buf);
  buf += 4;
  std::string index_name(buf, len);
  buf += len;
  // table id
  table_id_t table_id = MACH_READ_FROM(table_id_t, buf);
  buf += 4;
  // index key count
  uint32_t index_key_count = MACH_READ_UINT32(buf);
  buf += 4;
  // key mapping in table
  std::vector<uint32_t> key_map;
  for (uint32_t i = 0; i < index_key_count; i++) {
    uint32_t key_index = MACH_READ_UINT32(buf);
    buf += 4;
    key_map.push_back(key_index);
  }
  // allocate space for index meta data
  index_meta = new IndexMetadata(index_id, index_name, table_id, key_map);
  return buf - p;
}
```
`TableMetadata`的序列化：
```cpp
uint32_t TableMetadata::SerializeTo(char *buf) const {
  char *p = buf;
  uint32_t ofs = GetSerializedSize();
  ASSERT(ofs <= PAGE_SIZE, "Failed to serialize table info.");
  // magic num
  MACH_WRITE_UINT32(buf, TABLE_METADATA_MAGIC_NUM);
  buf += 4;
  // table id
  MACH_WRITE_TO(table_id_t, buf, table_id_);
  buf += 4;
  // table name
  MACH_WRITE_UINT32(buf, table_name_.length());
  buf += 4;
  MACH_WRITE_STRING(buf, table_name_);
  buf += table_name_.length();
  // table heap root page id
  MACH_WRITE_TO(page_id_t, buf, root_page_id_);
  buf += 4;
  // table schema
  buf += schema_->SerializeTo(buf);
  ASSERT(buf - p == ofs, "Unexpected serialize size.");
  return ofs;
}

uint32_t TableMetadata::GetSerializedSize() const {
  return 4 + 4 + MACH_STR_SERIALIZED_SIZE(table_name_) + 4 + schema_->GetSerializedSize();
}

uint32_t TableMetadata::DeserializeFrom(char *buf, TableMetadata *&table_meta) {
  if (table_meta != nullptr) {
    LOG(WARNING) << "Pointer object table info is not null in table info deserialize." << std::endl;
  }
  char *p = buf;
  // magic num
  uint32_t magic_num = MACH_READ_UINT32(buf);
  buf += 4;
  ASSERT(magic_num == TABLE_METADATA_MAGIC_NUM, "Failed to deserialize table info.");
  // table id
  table_id_t table_id = MACH_READ_FROM(table_id_t, buf);
  buf += 4;
  // table name
  uint32_t len = MACH_READ_UINT32(buf);
  buf += 4;
  std::string table_name(buf, len);
  buf += len;
  // table heap root page id
  page_id_t root_page_id = MACH_READ_FROM(page_id_t, buf);
  buf += 4;
  // table schema
  TableSchema *schema = nullptr;
  buf += TableSchema::DeserializeFrom(buf, schema);
  // allocate space for table metadata
  table_meta = new TableMetadata(table_id, table_name, root_page_id, schema);
  return buf - p;
}
```
`IndexInfo`的初始化：

```cpp
void Init(IndexMetadata *meta_data, TableInfo *table_info, BufferPoolManager *buffer_pool_manager) {
    // Step1: init index metadata and table info
    this->meta_data_=meta_data;
    // Step2: mapping index key to key schema
    this->key_schema_=Schema::ShallowCopySchema(table_info->GetSchema(),meta_data->GetKeyMapping());
    // Step3: call CreateIndex to create the index
    this->index_=CreateIndex(buffer_pool_manager, "bptree");
  }
```

#### 2.2.2 表和索引的管理

利用`CatalogManager`类维护和持久化数据库中所有表和索引的信息。

在数据库实例(`DBStorageEngine`)初次创建时(`init==True`)，初始化元数据；在后续重新打开数据库实例时，从数据库文件中加载所有表和索引的信息，构建`TableInfo`和`IndexInfo`信息置于内存中。

此外，还需要对上层模块提供对指定数据表的操作方式，`CreateTable`、`GetTable`、`GetTables`、`DropTable`、`GetTableIndexes`；对上层模块提供对指定索引的操作方式，如`CreateIndex`、`GetIndex`、`DropIndex`。

- 构造函数`CatalogManager`

初次创建时，初始化元数据；否则，先反序列化元数据，再从元数据的`table_meta_pages`和`index_meta_pages`中分别取出所有表和索引所在的数据页，并构建`TableInfo`和`IndexInfo`信息置于内存(`tables_`和`indexes_`)中。

```cpp
CatalogManager::CatalogManager(BufferPoolManager *buffer_pool_manager, LockManager *lock_manager,
                               LogManager *log_manager, bool init)
    : buffer_pool_manager_(buffer_pool_manager), lock_manager_(lock_manager), log_manager_(log_manager) {
      next_index_id_.store(0);
      next_table_id_.store(0);
      if(init)
      {
        catalog_meta_=new CatalogMeta();
      }
      else
      {
        Page *metapage=buffer_pool_manager_->FetchPage(CATALOG_META_PAGE_ID);
        char* buf=metapage->GetData();
        catalog_meta_=CatalogMeta::DeserializeFrom(buf);
        buffer_pool_manager_->UnpinPage(CATALOG_META_PAGE_ID,false);
        for(auto iter : catalog_meta_->table_meta_pages_)
        {
          page_id_t table_page_id=iter.second;
          Page* table_page=buffer_pool_manager_->FetchPage(table_page_id);
          char *buf2=table_page->GetData();
          TableMetadata *table_metadata;
          TableMetadata::DeserializeFrom(buf2, table_metadata);
          TableHeap *table_heap=TableHeap::Create(buffer_pool_manager_,table_metadata->GetFirstPageId(),table_metadata->GetSchema(),log_manager_,lock_manager_);
          table_names_[table_metadata->GetTableName()]=table_metadata->GetTableId();
          TableInfo *table_info=TableInfo::Create();
          table_info->Init(table_metadata,table_heap);
          tables_[table_metadata->GetTableId()]=table_info;
          buffer_pool_manager->UnpinPage(table_page_id, false);
        }
        for(auto iter : catalog_meta_->index_meta_pages_)
        {
          page_id_t index_page_id=iter.second;
          Page* index_page=buffer_pool_manager_->FetchPage(index_page_id);
          char *buf2=index_page->GetData();
          IndexMetadata *index_metadata;
          IndexMetadata::DeserializeFrom(buf2, index_metadata);
          std::string table_name=tables_[index_metadata->GetTableId()]->GetTableName();
          index_names_[table_name][index_metadata->GetIndexName()]=index_metadata->GetIndexId();
          IndexInfo *index_info=IndexInfo::Create();
          index_info->Init(index_metadata,tables_[index_metadata->GetTableId()],buffer_pool_manager_);
          indexes_[index_metadata->GetIndexId()]=index_info;
          buffer_pool_manager_->UnpinPage(index_page_id, false);
        }
      }
}
```

- 析构函数`~CatalogManager`

刷新元数据页后删除当前内存中的表和索引信息
```cpp
dberr_t CatalogManager::FlushCatalogMetaPage() const {
  Page* meta_page=buffer_pool_manager_->FetchPage(CATALOG_META_PAGE_ID);
  if(meta_page==nullptr)return DB_FAILED;
  char *buf=meta_page->GetData();
  catalog_meta_->SerializeTo(buf);
  buffer_pool_manager_->FlushPage(CATALOG_META_PAGE_ID);
  buffer_pool_manager_->UnpinPage(CATALOG_META_PAGE_ID,false);
  return DB_SUCCESS;
}
```

- `CreateTable`

先判断名称为`table_name`的数据表是否已经被创建。若尚未被创建，给`Table`分配新的`table_id`和用于存储数据的数据页(`new_page_id`)，将`table_metadata`序列化到`new_page`中并在元数据中添加相关信息。
```cpp
dberr_t CatalogManager::CreateTable(const string &table_name, TableSchema *schema, Txn *txn, TableInfo *&table_info) {
  if(table_names_.find(table_name)!=table_names_.end())
  {
    return DB_TABLE_ALREADY_EXIST;
  }
  table_id_t new_table_id=catalog_meta_->GetNextTableId();
  table_names_[table_name]=new_table_id;

  Schema* now_schema=Schema::DeepCopySchema(schema);
  page_id_t new_page_id;
  Page *new_table_page=buffer_pool_manager_->NewPage(new_page_id);
  char *buf=new_table_page->GetData();
  catalog_meta_->table_meta_pages_[new_table_id]=new_page_id;
  TableMetadata *new_table_metadata=TableMetadata::Create(new_table_id, table_name,new_page_id,now_schema);
  new_table_metadata->SerializeTo(buf);
  TableHeap *new_table_heap=TableHeap::Create(buffer_pool_manager_, now_schema, txn, log_manager_, lock_manager_);
  table_info=TableInfo::Create();
  table_info->Init(new_table_metadata, new_table_heap);

  tables_[new_table_id]=table_info;
  buffer_pool_manager_->UnpinPage(new_page_id,true);
  return DB_SUCCESS;
}
```

- `GetTable`和`GetTables`

如果要求的`Table(s)`存在，从`tables_`中取出对应的`TableInfo(s)`并返回。
```cpp
dberr_t CatalogManager::GetTable(const string &table_name, TableInfo *&table_info) {
  auto it=table_names_.find(table_name);
  if(it==table_names_.end())
  {
    return DB_TABLE_NOT_EXIST;
  }
  table_info=tables_[it->second];
  return DB_SUCCESS;
}

dberr_t CatalogManager::GetTables(vector<TableInfo *> &tables) const {
  tables.reserve(tables_.size());
  for(auto iter : tables_)
  {
   tables.push_back(iter.second); 
  }
  return DB_SUCCESS;
}
```

- `CreateIndex`

先判断表名为`table_name`的数据表是否存在，再判断表中是否已经建立名为`index_name`的索引。若尚未建立，从`table_name`的表中获取`TableInfo`，从`TableInfo`中获取数据表的`Schema`，再从`Schema`中获取`Index`所需的`key_map`。给`Index`分配新的`index_id`和数据页`new_page_id`。将`index_metadata`序列化到数据页中，将数据表中元组插入索引当中，再在元数据中添加相关的信息。
```cpp
dberr_t CatalogManager::CreateIndex(const std::string &table_name, const string &index_name,
                                    const std::vector<std::string> &index_keys, Txn *txn, IndexInfo *&index_info,
                                    const string &index_type) {//建立索引时，如果表中有数据，把数据插入索引
  if(table_names_.find(table_name)==table_names_.end())
  {
    return DB_TABLE_NOT_EXIST;
  }
  if(index_names_[table_name].find(index_name)!=index_names_[table_name].end())
  {
    return DB_INDEX_ALREADY_EXIST;
  }

  TableInfo *table_info=tables_[table_names_[table_name]];
  Schema *now_schema=table_info->GetSchema();
  std::vector<uint32_t>key_map;
  for(auto iter : index_keys)
  {
    uint32_t col_index;
    if(now_schema->GetColumnIndex(iter, col_index)==DB_COLUMN_NAME_NOT_EXIST)return DB_COLUMN_NAME_NOT_EXIST;
    else key_map.push_back(col_index);
  }

  index_id_t new_index_id=catalog_meta_->GetNextIndexId();
  index_names_[table_name][index_name]=new_index_id;

  page_id_t new_page_id;
  Page *new_index_page=buffer_pool_manager_->NewPage(new_page_id);
  char *buf=new_index_page->GetData();
  catalog_meta_->index_meta_pages_[new_index_id]=new_page_id;

  IndexMetadata *new_index_metadata=IndexMetadata::Create(new_index_id,index_name, table_names_[table_name],key_map);
  new_index_metadata->SerializeTo(buf);
  index_info=IndexInfo::Create();
  index_info->Init(new_index_metadata,table_info, buffer_pool_manager_);
  TableIterator new_table_iterator=table_info->GetTableHeap()->Begin(txn);
  while(new_table_iterator!=table_info->GetTableHeap()->End())
  {
    Row key_row;
    new_table_iterator->GetKeyFromRow(table_info->GetSchema(),index_info->GetIndexKeySchema(),key_row);
    dberr_t Ins_message=index_info->GetIndex()->InsertEntry(key_row,new_table_iterator->GetRowId(),txn);
    if(Ins_message==DB_FAILED)return DB_FAILED;
    new_table_iterator++;
  }//向索引中插入数据
  indexes_[new_index_id]=index_info;

  buffer_pool_manager_->UnpinPage(new_page_id,true);

  return DB_SUCCESS;
}
```

- `LoadTable`

先判断当前`Table`是否已经被加载到内存中。若没有，从输入的数据页中反序列化`TableInfo`，再更新元数据中的相关信息。
```cpp
dberr_t CatalogManager::LoadTable(const table_id_t table_id, const page_id_t page_id) {
  if(tables_.find(table_id)!=tables_.end())return DB_TABLE_ALREADY_EXIST;
  catalog_meta_->table_meta_pages_[table_id]=page_id;
  Page *now_table_page=buffer_pool_manager_->FetchPage(page_id);
  char *buf=now_table_page->GetData();
  TableMetadata *now_table_metadata;
  TableMetadata::DeserializeFrom(buf, now_table_metadata);
  TableHeap *now_table_heap=TableHeap::Create(buffer_pool_manager_,page_id,now_table_metadata->GetSchema(),log_manager_, lock_manager_);
  table_names_[now_table_metadata->GetTableName()]=now_table_metadata->GetTableId();
  TableInfo *now_table_info=TableInfo::Create();
  now_table_info->Init(now_table_metadata,now_table_heap);
  tables_[table_id]=now_table_info;
  buffer_pool_manager_->UnpinPage(page_id, false);
  return DB_SUCCESS;
}
```

- `GetIndex`和`GetTableIndexes`

先判断对应的数据表是否存在，再判断对应的索引是否存在。如果存在，从`indexes_`中获取相应的`IndexInfo`并返回。
```cpp
dberr_t CatalogManager::GetIndex(const std::string &table_name, const std::string &index_name,
                                 IndexInfo *&index_info) const {
  if(index_names_.find(table_name)==index_names_.end())return DB_TABLE_NOT_EXIST;
  auto it=index_names_.at(table_name).find(index_name);
  if(it==index_names_.at(table_name).end())return DB_INDEX_NOT_FOUND;
  index_info=indexes_.at(it->second);
  return DB_SUCCESS;
}

dberr_t CatalogManager::GetTableIndexes(const std::string &table_name, std::vector<IndexInfo *> &indexes) const {
  if(index_names_.find(table_name)==index_names_.end())return DB_TABLE_NOT_EXIST;
  for(auto iter : index_names_.at(table_name))
  {
    indexes.push_back(indexes_.at(iter.second));
  }
  return DB_SUCCESS;
```

- `DropTable`

先判断对应的数据表是否存在。若存在，先删掉建立在表上的所有索引(`DropIndex`)，再删掉存储数据表的数据页，再在元数据中删除对应的数据表信息。
```cpp
dberr_t CatalogManager::DropTable(const string &table_name) {
  if(table_names_.find(table_name)==table_names_.end())return DB_TABLE_NOT_EXIST;
  std::vector<IndexInfo *>Indexes;
  if(GetTableIndexes(table_name, Indexes)==DB_SUCCESS)
  {
    for(auto iter : Indexes)
    {
      DropIndex(table_name, iter->GetIndexName());
    }
  }
  table_id_t now_table_id=table_names_[table_name];
  page_id_t now_page_id=catalog_meta_->table_meta_pages_[now_table_id];
  buffer_pool_manager_->DeletePage(now_page_id);
  catalog_meta_->table_meta_pages_.erase(now_table_id);
  tables_.erase(now_table_id);
  table_names_.erase(table_name);
  return DB_SUCCESS;
}
```

- `DropIndex`

先判断对应的索引是否存在，再删掉存储索引的数据页，再在元数据中删除对应的索引信息。
```cpp
dberr_t CatalogManager::DropIndex(const string &table_name, const string &index_name) {
  if(index_names_.find(table_name)==index_names_.end())return DB_TABLE_NOT_EXIST;
  auto it=index_names_.at(table_name).find(index_name);
  if(it==index_names_.at(table_name).end())return DB_INDEX_NOT_FOUND;
  index_id_t now_index_id=it->second;
  page_id_t now_page_id=catalog_meta_->index_meta_pages_[now_index_id];
  buffer_pool_manager_->DeletePage(now_page_id);
  catalog_meta_->index_meta_pages_.erase(now_index_id);
  indexes_.erase(now_index_id);
  index_names_.at(table_name).erase(index_name);
  return DB_SUCCESS;
}
```
- `FlushCatalogMetaPage`
  
将`catalog_meta`写入`CATALOG_META_PAGE`中，再刷新数据页。

```cpp
dberr_t CatalogManager::FlushCatalogMetaPage() const {
  Page* meta_page=buffer_pool_manager_->FetchPage(CATALOG_META_PAGE_ID);
  if(meta_page==nullptr)return DB_FAILED;
  char *buf=meta_page->GetData();
  catalog_meta_->SerializeTo(buf);
  buffer_pool_manager_->FlushPage(CATALOG_META_PAGE_ID);
  buffer_pool_manager_->UnpinPage(CATALOG_META_PAGE_ID,false);
  return DB_SUCCESS;
}
```

- `LoadIndex`

先判断当前`Index`是否已经被加载到内存中。若没有，从输入的数据页中反序列化`IndexInfo`，再更新元数据中的相关信息。
```cpp
dberr_t CatalogManager::LoadIndex(const index_id_t index_id, const page_id_t page_id) {
  if(indexes_.find(index_id)!=indexes_.end())return DB_INDEX_ALREADY_EXIST;
  catalog_meta_->index_meta_pages_[index_id]=page_id;
  Page *now_index_page=buffer_pool_manager_->FetchPage(page_id);
  char *buf=now_index_page->GetData();
  IndexMetadata *now_index_metadata;
  IndexMetadata::DeserializeFrom(buf, now_index_metadata);
  std::string table_name=tables_[now_index_metadata->GetTableId()]->GetTableName();
  index_names_[table_name][now_index_metadata->GetIndexName()]=now_index_metadata->GetIndexId();
  IndexInfo *now_index_info=IndexInfo::Create();
  now_index_info->Init(now_index_metadata, tables_[now_index_metadata->GetTableId()],buffer_pool_manager_);
  indexes_[index_id]=now_index_info;
  buffer_pool_manager_->UnpinPage(page_id, false);
  return DB_SUCCESS;
}
```
**测试代码**

运行`catalog_test.cpp`进行测试，未额外添加测试代码。

### 2.3 Lab7

#### 2.3.1 事务管理器Txn Manager

事务管理器负责处理所有与事务相关操作，是维护数据库ACID属性（原子性、一致性、隔离性、持久性）的关键组件，主要负责以下方面：
- 事务的边界控制：负责定义事务的开始(BEGIN TRANSACTION)和结束(COMMIT或ROLLBACK)。事务开始时，事务管理器为其分配所需资源，并追踪状态。事务成功完成时，事务管理器执行提交操作，将更改永久写入数据库。若事务错误或需要撤销，事务管理器执行回滚操作，撤销所有更改。
- 并发控制：在允许多个事务同时运行的系统中，使用并发控制机制（如锁、时间戳、版本号lsn）来确保事务不会相互干扰，导致数据不一致。实现数据库的隔离级别，防止并发事务产生冲突。
- 恢复管理：保证在系统故障（如崩溃、电源中断）后数据库的一致性和持久性。通常通过使用日志记录(Logging)和检查点(Checkpointing)等技术完成。事务日志存储了所有对数据库所做的更改的记录，可用于恢复操作。
- 故障处理：检测到错误或异常时，事务管理器负责采取适当行动，如触发回滚来撤销事务的操作，或在某些情况下尝试恢复事务执行

**Txn Manager类已在框架中实现。**

#### 2.3.2 锁管理器LockManager

锁管理器维护当前活动事务所持有的锁。事务在访问数据前向Lock Manager发出锁请求，由Lock Manager决定是否将锁授予该事务，或是否阻塞该事务或中止事务。

Lock Manager内定义了`LockRequest`和`LockRequestQueue`两类

其中`LockRequest`类代表事务发出的锁请求，包括：
- `txn_id_`：发出请求的事务的标识符。
- `lock_mode_`：请求的锁类型。
- `granted_`：已授予事务的锁类型。

`LockRequestQueue`类管理锁请求队列，并提供操作它的方法。它使用一个列表`req_list`存储请求，并使用一个unordered_map(`req_list_iter_map`)跟踪列表中每一个请求的迭代器。它还包括一个条件变量`cv_`用于同步目的，以及一些标志管理并发访问：
- `is_writing_`：指示当前是否持有排他性写锁。
- `is_upgrading_`：指示是否正在进行锁升级。
- `sharing_cnt_`：持有共享锁的事务数量的计数

该类提供以下方法：
- `EmplaceLockRequest()`：将新的锁请求添加到队列前端，并在map中存储其迭代器。
- `EraseLockRequest()`：根据`txn_id`从队列和map中移除锁请求。成功则返回`True`，否则返回`False`。
- `GetLockRequestIter()`：根据`txn_id`检索队列中特定锁请求的迭代器。

`LockManager`类中的待实现函数：

- `LockPrepare(Txn, RID)`：检查txn的state是否符合预期，并在`lock_table_`里创建rid和对应的队列。

如果事务处于收缩阶段，则不应该加锁，将事务设为Aborted状态并抛出异常。
否则，如果`lock_table_`中没有rid中对应的队列，则在`lock_table_`中添加相应的队列。
```cpp
void LockManager::LockPrepare(Txn *txn, const RowId &rid) {//rid加入lock_table_中
  if(txn->GetState()==TxnState::kShrinking)
  {
    txn->SetState(TxnState::kAborted);
    throw TxnAbortException(txn->GetTxnId(),AbortReason::kLockOnShrinking);
  }
  if(lock_table_.find(rid)==lock_table_.end())
  {
    lock_table_.emplace(std::piecewise_construct, std::forward_as_tuple(rid), std::forward_as_tuple());
  }
}
```

- `CheckAbort(Txn, LockRequestQueue)`：检查txn的state是否为Aborted，并做出相应操作。

如果state为Aborted，则在`req_queue`中删除对应的lockrequest并抛出异常。
```cpp
void LockManager::CheckAbort(Txn *txn, LockManager::LockRequestQueue &req_queue) {
  if(txn->GetState()==TxnState::kAborted)
  {
    req_queue.EraseLockRequest(txn->GetTxnId());
    throw TxnAbortException(txn->GetTxnId(),AbortReason::kDeadlock);//等待资源时终止，为死锁检测
  }
}
```

- `LockShared(Txn, RID)`：事务txn请求获取id为rid的数据记录上的共享锁。当请求需要等待时，该函数被阻塞(cv_.wait)，请求通过后返回True。

如果数据库的隔离级别为`ReadUncommitted`，则不应该添加共享锁，将事务状态设置为Aborted并抛出异常。

接着执行`LockPrepare`，并在对应的`LockRequestQueue`中加入共享锁请求。

如果正持有排他性写锁，阻塞事务直到不再持有排他性写锁或事务被中止。

执行`CheckAbort`检测事务状态。

给事务分配共享锁，更新相关信息。
```cpp
bool LockManager::LockShared(Txn *txn, const RowId &rid) {
  std::unique_lock<std::mutex>lock(latch_);//防止并发访问
  if(txn->GetIsolationLevel()==IsolationLevel::kReadUncommitted)//ReadUncommitted的level不加锁
  {
    txn->SetState(TxnState::kAborted);
    throw TxnAbortException(txn->GetTxnId(),AbortReason::kLockSharedOnReadUncommitted);
  }
  LockPrepare(txn, rid);

  LockRequestQueue &now_queue=lock_table_[rid];
  now_queue.EmplaceLockRequest(txn->GetTxnId(),LockMode::kShared);

  if(now_queue.is_writing_)
  {
    now_queue.cv_.wait(lock, [&now_queue, txn]{return !now_queue.is_writing_ || txn->GetState()==TxnState::kAborted;});
  }

  CheckAbort(txn,now_queue);

  txn->GetSharedLockSet().insert(rid);
  ++now_queue.sharing_cnt_;
  now_queue.GetLockRequestIter(txn->GetTxnId())->granted_=LockMode::kShared;//实际分配share锁

  return true;
}
```

- `LockExclusive(Txn, RID)`：事务txn请求获取id为rid的数据记录上的独占锁。当请求需要等待时，该函数被阻塞，请求通过后返回True。

执行`LockPrepare`，并在对应的`LockRequestQueue`中加入排他锁请求。

如果正持有排他性写锁或共享锁，阻塞事务直到（没有排他性写锁和共享锁）或事务被中止

执行`CheckAbort`检测事务状态。

给事务分配排他锁，更新相关信息。
```cpp
bool LockManager::LockExclusive(Txn *txn, const RowId &rid) {
    std::unique_lock<std::mutex>lock(latch_);
    
    LockPrepare(txn, rid);

    LockRequestQueue &now_queue=lock_table_[rid];
    now_queue.EmplaceLockRequest(txn->GetTxnId(),LockMode::kExclusive);

    if(now_queue.is_writing_||now_queue.sharing_cnt_>0)
    {
      now_queue.cv_.wait(lock,[&now_queue, txn]{return txn->GetState()==TxnState::kAborted||(!now_queue.is_writing_&&now_queue.sharing_cnt_==0);});
    }
    CheckAbort(txn, now_queue);

    txn->GetExclusiveLockSet().insert(rid);
    now_queue.is_writing_=true;
    now_queue.GetLockRequestIter(txn->GetTxnId())->granted_=LockMode::kExclusive;

    return true;
}
```

- `LockUpgrade(Txn, RID)`：事务txn请求更新id为rid的数据记录上的锁为独占锁，当请求需要等待时，该函数被阻塞，请求通过后返回True。

执行`LockPrepare`。

如果已经有正在更新的锁，则因为更新冲突中止当前事务，抛出异常。

检查当前分配的锁是否已经是排他锁，若是，无需更新，返回True。

将请求的锁类型更新为排他锁，如果正持有排他性写锁或其它共享锁，阻塞事务直到（没有排他性写锁且仅当前事务持有共享锁）或事务被中止

执行`CheckAbort`检测事务状态。

给事务分配排他锁并更新相关信息。
```cpp
bool LockManager::LockUpgrade(Txn *txn, const RowId &rid) {
    std::unique_lock<std::mutex>lock(latch_);
    
    LockPrepare(txn,rid);

    LockRequestQueue &now_queue=lock_table_[rid];
    if(now_queue.is_upgrading_)
    {
      txn->SetState(TxnState::kAborted);
      throw TxnAbortException(txn->GetTxnId(),AbortReason::kUpgradeConflict);
    }

    auto iter=now_queue.GetLockRequestIter(txn->GetTxnId());

    if(iter->lock_mode_==LockMode::kExclusive&&iter->granted_==LockMode::kExclusive)return true;//already grant Exclusive

    iter->lock_mode_=LockMode::kExclusive;

    if(now_queue.is_writing_||now_queue.sharing_cnt_>1)
    {
      now_queue.is_upgrading_=true;
      now_queue.cv_.wait(lock,[&now_queue, txn]{return txn->GetState()==TxnState::kAborted||(!now_queue.is_writing_&&now_queue.sharing_cnt_==1);});
    }

    now_queue.is_upgrading_=false;
    CheckAbort(txn,now_queue);

    iter->granted_=LockMode::kExclusive;
    now_queue.sharing_cnt_=0;
    now_queue.is_writing_=true;

    txn->GetSharedLockSet().erase(rid);
    txn->GetExclusiveLockSet().insert(rid);

    return true;
}
```

- `Unlock(Txn, RID）`：释放事务txn在rid数据记录上的锁。

在事务的锁集合中删除对应的`rid`。

在`LockRequestQueue`中删除对应的事务。

如果事务正处于增长阶段且（数据库隔离级别并非`ReadCommitted` 且 当前接触的锁并非共享锁——`ReadCommitted`级别下不需要严格遵循两阶段），将事务转变为收缩阶段。

更新相关信息并使用`notify_all()`方法通知等待中的事务。
```cpp
bool LockManager::Unlock(Txn *txn, const RowId &rid) {
  std::unique_lock<std::mutex>lock(latch_);

  txn->GetSharedLockSet().erase(rid);
  txn->GetExclusiveLockSet().erase(rid);

  LockRequestQueue &now_queue=lock_table_[rid];
  auto iter=now_queue.GetLockRequestIter(txn->GetTxnId());
  LockMode now_lock_mode=iter->granted_;

  now_queue.EraseLockRequest(txn->GetTxnId());

  if(txn->GetState()==TxnState::kGrowing&&!(txn->GetIsolationLevel()==IsolationLevel::kReadCommitted&&now_lock_mode==LockMode::kShared))
  {
    txn->SetState(TxnState::kShrinking);
  }
  if(now_lock_mode==LockMode::kShared)
  {
    --now_queue.sharing_cnt_;
  }
  else if(now_lock_mode==LockMode::kExclusive)
  {
    now_queue.is_writing_=false;
  }
  now_queue.cv_.notify_all();
  
  return true;
}
```
#### 2.3.3 死锁检测

锁管理器在后台运行死锁检测，以中止阻塞事务。

后台线程定期即时构建等待图，并打破任何环。

待实现函数如下：

- `AddEdge(txn_id_t t1, txn_id_t t2)`

在等待图中添加t1连到t2的有向边。若该边已经存在，无需操作。
```cpp
void LockManager::AddEdge(txn_id_t t1, txn_id_t t2) {waits_for_[t1].insert(t2);}
```

- `RemoveEdge(txn_id_t t1, txn_id_t t2)`

在等待图中删除t1连到t2的有向边。若该边已经存在，无需操作。
```cpp
void LockManager::RemoveEdge(txn_id_t t1, txn_id_t t2) {waits_for_[t1].erase(t2);}
```

- 辅助找环函数`dfs(txn_id_t now)`

在等待图中按照`txn_id`从小到大的顺序依次进行深度优先搜索，找到环则返回True，否则返回False。
```cpp
bool LockManager::dfs(txn_id_t now)
{
  if(visited_set_.find(now)!=visited_set_.end())
  {
    return true;
  }

  visited_set_.insert(now);
  visited_path_.push(now);

  for(auto it:waits_for_[now])
  {
    if(dfs(it))return true;
  }

  visited_set_.erase(now);
  visited_path_.pop();

  return false;
}
```

- 找环函数`HasCycle(txn_id_t &txn_id)`

在等待图中利用辅助函数`dfs`找环，在所有环中找到`txn_id`最大的事务（最年轻的事务）并返回。找到环则返回True，否则返回False。
```cpp
bool LockManager::HasCycle(txn_id_t &newest_tid_in_cycle) {
  visited_set_.clear();
  while(!visited_path_.empty())visited_path_.pop();
  
  std::set<txn_id_t>nodes;

  for(auto iter1:waits_for_)
  {
    nodes.insert(iter1.first);
    for(auto iter2:iter1.second)
    {
      nodes.insert(iter2);
    }
  }

  newest_tid_in_cycle=INVALID_TXN_ID;

  for(auto it:nodes)
  {
    if(visited_set_.find(it)!=visited_set_.end())continue;
    if(dfs(it))
    {
      while(!visited_path_.empty())
      {
        newest_tid_in_cycle=std::max(newest_tid_in_cycle,visited_path_.top());
        visited_path_.pop();
      }
      return true;
    }
  }
  
  return false;
}
```

- `GetEdgeList()`：返回一个元组列表，代表图中的边。(t1,t2)表示t1连向t2的边。
```cpp
std::vector<std::pair<txn_id_t, txn_id_t>> LockManager::GetEdgeList() {
    std::vector<std::pair<txn_id_t, txn_id_t>> result;
    for(auto iter:waits_for_)
    {
      for(auto iter2:iter.second)
      {
        result.push_back(std::make_pair(iter.first,iter2));
      }
    }
    return result;
}
```

- `DeleteNode(txn_id_t txn_id)`：在等待图中删除点和相关的所有边。
```cpp
void LockManager::DeleteNode(txn_id_t txn_id) {
    waits_for_.erase(txn_id);
    auto *txn = txn_mgr_->GetTransaction(txn_id);

    for(auto &iter:lock_table_)
    {
      for(auto &u:iter.second.req_list_)
      {
        if(u.txn_id_==txn_id&&u.granted_==LockMode::kNone)
        {
          for(auto &v:iter.second.req_list_)
          {
            if(v.granted_!=LockMode::kNone)
            {
              RemoveEdge(u.txn_id_,v.txn_id_);
            }
          }
        }
      }
    }
    
    for (auto &row_id: txn->GetSharedLockSet()) {
        for (auto &lock_req: lock_table_[row_id].req_list_) {
            if (lock_req.granted_ == LockMode::kNone) {
                RemoveEdge(lock_req.txn_id_, txn_id);
            }
        }
    }

    for (auto &row_id: txn->GetExclusiveLockSet()) {
        for (auto &lock_req: lock_table_[row_id].req_list_) {
            if (lock_req.granted_ == LockMode::kNone) {
                RemoveEdge(lock_req.txn_id_, txn_id);
            }
        }
    }
}
```
- `RunCycleDetection()`：包含在后台运行循环检测的框架代码。在此实现循环检测逻辑。

等待`interval`的时间。

建立`txn_id`到`rid`的映射，用于从事务获取`LockRequestQueue`。

建立等待图，从待分配锁的事务向同一数据记录上已分配锁的事务连边。

打破图中的所有环。有环时取出所有环中最年轻的事务并设置为`Aborted`，对这个事务执行`DeleteNode`并利用`txn_id`到`rid`的映射，获取`LockRequestQueue`并执行`cv_.notify_all()`。

破除所有环后，清除等待图。
```cpp
void LockManager::RunCycleDetection() {
  while(enable_cycle_detection_)
  {
    std::this_thread::sleep_for(cycle_detection_interval_);
    std::unique_lock<std::mutex> lock(latch_);
    std::unordered_map<txn_id_t, RowId> txn_to_rid;
    for(auto &iter:lock_table_)
    {
      for(auto &u:iter.second.req_list_)
      {
        txn_to_rid[u.txn_id_]=iter.first;
        if(u.granted_==LockMode::kNone)
        {
          for(auto &v:iter.second.req_list_)
          {
            if(v.granted_!=LockMode::kNone)
            {
              AddEdge(u.txn_id_,v.txn_id_);
            }
          }
        }
      }
    }
    txn_id_t to_be_deleted_id=INVALID_TXN_ID;
    while(HasCycle(to_be_deleted_id))
    {
      Txn *to_be_deleted=txn_mgr_->GetTransaction(to_be_deleted_id);
      to_be_deleted->SetState(TxnState::kAborted);
      DeleteNode(to_be_deleted_id);
      lock_table_[txn_to_rid[to_be_deleted_id]].cv_.notify_all();
    }
    waits_for_.clear();
  }
}
```

**测试代码**

运行`lock_manager_test`进行测试，未额外添加测试代码。


### 2.4 Lab3 Index Manager

因`catalog_test`运行失败，查错时发现`b_plus_tree.cpp`中`BPlusTree`的构造函数中，没有去`IndexrootPage`里面查看索引b+树的根是否存在。后联系负责对应模块的同学更正。

### 2.5 Lab5 Planner and Executor

因`executor_test`运行失败，查错时发现`FetchPage`中，如果`page_id`为无效页号，需要返回`nullptr`。后联系负责对应模块的同学更正。