<center><h1>MiniSQL 个人报告</h1></center>

<center>杨正宇，3220104117</center>

## 1. 负责部分

- $\text{Lab 3}$ 的全部模块实现和测试。

- $\text{Lab 1}$ 的辅助 Debug。

- $\text{Lab 4}$ 的辅助 Debug。

- 整体的测试
  

## 2. 实验概述
本模块负责数据表索引的实现和管理，包括：
- 索引的创建和删除，
- 索引键的等值查找，
- 索引键的范围查找（返回对应的迭代器），
- 以及插入和删除键值等操作

本实验实现一个**基于磁盘的**B+树动态索引结构


## 3. B+树数据页
B+树中的每个结点（Node）都对应一个数据页，用于存储B+树结点中的数据。数据页分为 **页头（Page Header）** 和 **数据区（Data Area）** 两部分。页头用于存储数据页的元信息，数据区用于存储数据。页头的信息定义在`BPlusTreePage`中。根据B+树的形态，将数据页分为叶子页和非叶子页两种类型分别对应`BPlusTreeLeafPage`和`BPlusTreeInternalPage`。两者均继承自`BPlusTreePage`。在数据页中，序列化后的索引键值和对应的Value成对的存储在 `data_[]` 中，对于内点，存储的 Value 是子节点的 `page_id`；对于叶子点，存储的 Value 是数据表中该键值对应的 `row_id`。

### BPlusTreePage类
```cpp
class BPlusTreePage {
 public:
  bool IsLeafPage() const;

  bool IsRootPage() const;

  void SetPageType(IndexPageType page_type);

  int GetKeySize() const;

  void SetKeySize(int size);

  int GetSize() const;

  void SetSize(int size);

  void IncreaseSize(int amount);

  int GetMaxSize() const;

  void SetMaxSize(int max_size);

  int GetMinSize() const;

  page_id_t GetParentPageId() const;

  void SetParentPageId(page_id_t parent_page_id);

  page_id_t GetPageId() const;

  void SetPageId(page_id_t page_id);

  void SetLSN(lsn_t lsn = INVALID_LSN);

 private:
  // member variable, attributes that both internal and leaf page share
  IndexPageType page_type_; // page type
  int key_size_; // key size
  lsn_t lsn_; // log sequence number
  int size_; // number of keys in the page
  int max_size_; // max number of keys in the page
  page_id_t parent_page_id_; // parent page id
  page_id_t page_id_; // page id
};
```
两种page都共享private中的这7个属性，包含在页头中（leafpage多一个next_page_id_属性，在范围查找的时候有用）。

### BPlusTreeLeafPage类
```cpp
class BPlusTreeLeafPage : public BPlusTreePage {
 public:
  void Init(page_id_t page_id, page_id_t parent_id = INVALID_PAGE_ID, int key_size = UNDEFINED_SIZE,
            int max_size = UNDEFINED_SIZE);

  // helper methods
  page_id_t GetNextPageId() const;

  void SetNextPageId(page_id_t next_page_id);

  GenericKey *KeyAt(int index);

  void SetKeyAt(int index, GenericKey *key);

  RowId ValueAt(int index) const;

  void SetValueAt(int index, RowId value);

  int KeyIndex(const GenericKey *key, const KeyManager &comparator); // 返回 查找的key 所对应的 index

  void *PairPtrAt(int index); // 获取 data_[index] 位置指针

  void PairCopy(void *dest, void *src, int pair_num = 1);

  std::pair<GenericKey *, RowId> GetItem(int index);

  // insert and delete methods
  int Insert(GenericKey *key, const RowId &value, const KeyManager &comparator);

  bool Lookup(const GenericKey *key, RowId &value, const KeyManager &comparator);

  int RemoveAndDeleteRecord(const GenericKey *key, const KeyManager &comparator);

  // Split and Merge utility methods
  void MoveHalfTo(BPlusTreeLeafPage *recipient);

  void MoveAllTo(BPlusTreeLeafPage *recipient);

  void MoveFirstToEndOf(BPlusTreeLeafPage *recipient);

  void MoveLastToFrontOf(BPlusTreeLeafPage *recipient);

 private:
  void CopyNFrom(void *src, int size);

  void CopyLastFrom(GenericKey *key, const RowId value);

  void CopyFirstFrom(GenericKey *key, const RowId value);

  page_id_t next_page_id_{INVALID_PAGE_ID};

  char data_[PAGE_SIZE - LEAF_PAGE_HEADER_SIZE];
};
```
`BPlusTreeLeafPage`继承自`BPlusTreePage`，多了一个`next_page_id_`属性，用于指向下一个叶子页。


### BPlusTreeInternalPage类
```cpp
class BPlusTreeInternalPage : public BPlusTreePage {
 public:
  // must call initialize method after "create" a new node
  void Init(page_id_t page_id, page_id_t parent_id = INVALID_PAGE_ID, int key_size = UNDEFINED_SIZE,
            int max_size = UNDEFINED_SIZE);

  GenericKey *KeyAt(int index);

  void SetKeyAt(int index, GenericKey *key);

  int ValueIndex(const page_id_t &value) const;

  page_id_t ValueAt(int index) const;

  void SetValueAt(int index, page_id_t value);

  void *PairPtrAt(int index);

  void PairCopy(void *dest, void *src, int pair_num = 1);

  page_id_t Lookup(const GenericKey *key, const KeyManager &KP); // 查找 key 所对应的 value

  void PopulateNewRoot(const page_id_t &old_value, GenericKey *new_key, const page_id_t &new_value); // 将新的根节点设置为 old_value + new_key + new_value
  // PopulateNewRoot 只在分裂根节点的时候使用（此时要创建一个新的根）

  int InsertNodeAfter(const page_id_t &old_value, GenericKey *new_key, const page_id_t &new_value);

  void Remove(int index);

  page_id_t RemoveAndReturnOnlyChild();

  // Split and Merge utility methods
  void MoveAllTo(BPlusTreeInternalPage *recipient, GenericKey *middle_key, BufferPoolManager *buffer_pool_manager);

  void MoveHalfTo(BPlusTreeInternalPage *recipient, BufferPoolManager *buffer_pool_manager);

  void MoveFirstToEndOf(BPlusTreeInternalPage *recipient, GenericKey *middle_key,
                        BufferPoolManager *buffer_pool_manager);

  void MoveLastToFrontOf(BPlusTreeInternalPage *recipient, GenericKey *middle_key,
                         BufferPoolManager *buffer_pool_manager);

 private:
  void CopyNFrom(void *src, int size, BufferPoolManager *buffer_pool_manager);

  void CopyLastFrom(GenericKey *key, page_id_t value, BufferPoolManager *buffer_pool_manager);

  void CopyFirstFrom(page_id_t value, BufferPoolManager *buffer_pool_manager);

  char data_[PAGE_SIZE - INTERNAL_PAGE_HEADER_SIZE];
};
```
`BPlusTreeInternalPage`继承自`BPlusTreePage`，多了一个`data_[]`属性，用于存储子节点的`page_id`。他的函数中要多传入一个`BufferPoolManager`参数，用于在分裂和合并的时候对子节点的父节点进行修改

### 部分函数细节
1. `LeafPage::KeyIndex()`函数：二分查找key所对应的index，如果没有对应的，返回第一个大于key的index
```cpp
int LeafPage::KeyIndex(const GenericKey *key, const KeyManager &KM) {
  if(GetSize() == 0) {
    return 0;
  }
  int l = 0, r = GetSize() - 1, index = GetSize();
  // binary search
  while(l <= r) {
    int mid = (l + r) / 2;
    int cmp = KM.CompareKeys(key, KeyAt(mid));
    if(cmp == 0) {
      index = mid;
      break;
    }  else if(cmp < 0) { // key < KeyAt(mid)
      index = mid; //返回第一个大于key的index
      r = mid - 1;
    } else {
      l = mid + 1;
    }
  }
  return index;
}
```

2. `LeafPage::RemoveAndDeleteRecord()`函数：删除key对应的记录
```cpp
int LeafPage::RemoveAndDeleteRecord(const GenericKey *key, const KeyManager &KM) {
  int index = KeyIndex(key, KM);
  if (index < GetSize() && KM.CompareKeys(KeyAt(index), key) == 0) {
    PairCopy(PairPtrAt(index), PairPtrAt(index + 1), GetSize() - index - 1); //把index后的数据往前移
    IncreaseSize(-1);
    return GetSize();
  }
  LOG(ERROR) << "Key not found" << std::endl;
  return GetSize();
}
```


3. `InternalPage::Lookup()`函数：查找key所对应的value
```cpp
page_id_t InternalPage::Lookup(const GenericKey *key, const KeyManager &KM) {
  //return INVALID_PAGE_ID;
  int l = 1, r = GetSize() - 1, index = 0;
  int cmp;
  while (l <= r) {
    int mid = (l + r) / 2;
    cmp = KM.CompareKeys(key, KeyAt(mid));
    if (cmp == 0) {
      index = mid;
      break;
    } else if (cmp < 0) { //key < KeyAt(mid) 
      r = mid - 1;
    } else {  //key > KeyAt(mid)
      index = mid; //记录最后一个键不大于搜索键的位置
      l = mid + 1;
    }
  }
  return ValueAt(index);
}
```

4. `InternalPage::ICopyNFrom()`函数：将src中的size个数据复制到当前页中,并维护子节点的父节点信息
```cpp
void InternalPage::CopyNFrom(void *src, int size, BufferPoolManager *buffer_pool_manager) {
  PairCopy(PairPtrAt(GetSize()), src, size); 
  int new_pairs_offset = GetSize();
  IncreaseSize(size);
  //update parent page id of the child of the moved pages
  for (int index = new_pairs_offset; index < GetSize(); index++) {
    auto *page = buffer_pool_manager->FetchPage(ValueAt(index));
    if (page != nullptr) {
      auto *child = reinterpret_cast<BPlusTreePage *>(page->GetData());
      child->SetParentPageId(GetPageId());
      buffer_pool_manager->UnpinPage(child->GetPageId(), true);
    }
  }
}
```
注意要维护那些被移动的子节点的父节点信息

5. `InternalPage::MoveFirstToEndOf()`函数：将当前页的第一个键值对移动到recipient页的末尾
```cpp
void InternalPage::MoveFirstToEndOf(InternalPage *recipient, GenericKey *middle_key, BufferPoolManager *buffer_pool_manager) {

  SetKeyAt(0, middle_key); //0号位置的key变为middle_key
  GenericKey* key = KeyAt(0); //middle_key
  page_id_t value = ValueAt(0);
  recipient->CopyLastFrom(key, value, buffer_pool_manager);
  Remove(0);
}
```
0号位置的key是用来暂存的，不产生实际作用

```cpp
void InternalPage::CopyLastFrom(GenericKey *key, const page_id_t value, BufferPoolManager *buffer_pool_manager) {
  SetKeyAt(GetSize(), key);
  SetValueAt(GetSize(), value);
  auto child_page = reinterpret_cast<BPlusTreePage *>(buffer_pool_manager->FetchPage(value)->GetData());
  child_page->SetParentPageId(GetPageId());
  buffer_pool_manager->UnpinPage(child_page->GetPageId(), true); //更新子节点的父节点信息
  IncreaseSize(1);
}
```
父节点的middle_key的更新在上层模块完成，这层不考虑


## 4. B+树索引
在完成B+树结点的数据结构设计后，接下来需要完成B+树的创建、插入、删除、查找和释放等操作。注意，所设计的B+树只能支持Unique Key，这也意味着，当尝试向B+树插入一个重复的Key-Value键值对时，将不能执行插入操作并返回false状态。

当一些写操作导致B+树索引的根结点发生变化时，需要调用`BPLUSTREE_TYPE::UpdateRootPageId`完成`root_page_id`的变更和持久化。

#### BPlusTree类
```cpp
class BPlusTree {
  using InternalPage = BPlusTreeInternalPage;
  using LeafPage = BPlusTreeLeafPage;

 public:
  explicit BPlusTree(index_id_t index_id, BufferPoolManager *buffer_pool_manager, const KeyManager &comparator,
                     int leaf_max_size = UNDEFINED_SIZE, int internal_max_size = UNDEFINED_SIZE);

  // Returns true if this B+ tree has no keys and values.
  bool IsEmpty() const;

  // Insert a key-value pair into this B+ tree.
  bool Insert(GenericKey *key, const RowId &value, Txn *transaction = nullptr);

  // Remove a key and its value from this B+ tree.
  void Remove(const GenericKey *key, Txn *transaction = nullptr);

  // return the value associated with a given key
  bool GetValue(const GenericKey *key, std::vector<RowId> &result, Txn *transaction = nullptr);

  IndexIterator Begin();

  IndexIterator Begin(const GenericKey *key);

  IndexIterator End();

  // expose for test purpose
  Page *FindLeafPage(const GenericKey *key, page_id_t page_id = INVALID_PAGE_ID, bool leftMost = false);

  // used to check whether all pages are unpinned
  bool Check();

  // destroy the b plus tree
  void Destroy(page_id_t current_page_id = INVALID_PAGE_ID);

  void PrintTree(std::ofstream &out, Schema *schema) {
    if (IsEmpty()) {
      return;
    }
    out << "digraph G {" << std::endl;
    Page *root_page = buffer_pool_manager_->FetchPage(root_page_id_);
    auto *node = reinterpret_cast<BPlusTreePage *>(root_page->GetData());
    ToGraph(node, buffer_pool_manager_, out, schema);
    out << "}" << std::endl;
  }

 private:
  void StartNewTree(GenericKey *key, const RowId &value);

  bool InsertIntoLeaf(GenericKey *key, const RowId &value, Txn *transaction = nullptr);

  void InsertIntoParent(BPlusTreePage *old_node, GenericKey *key, BPlusTreePage *new_node, Txn *transaction = nullptr);

  LeafPage *Split(LeafPage *node, Txn *transaction);

  InternalPage *Split(InternalPage *node, Txn *transaction);

  template <typename N>
  bool CoalesceOrRedistribute(N *&node, Txn *transaction = nullptr);

  bool Coalesce(InternalPage *&neighbor_node, InternalPage *&node, InternalPage *&parent, int index,
                Txn *transaction = nullptr);

  bool Coalesce(LeafPage *&neighbor_node, LeafPage *&node, InternalPage *&parent, int index,
                Txn *transaction = nullptr);

  void Redistribute(LeafPage *neighbor_node, LeafPage *node, int index);

  void Redistribute(InternalPage *neighbor_node, InternalPage *node, int index);

  bool AdjustRoot(BPlusTreePage *node);

  void UpdateRootPageId(int insert_record = 0);

  /* Debug Routines for FREE!! */
  void ToGraph(BPlusTreePage *page, BufferPoolManager *bpm, std::ofstream &out, Schema *schema) const;

  void ToString(BPlusTreePage *page, BufferPoolManager *bpm) const;

  // member variable
  index_id_t index_id_;
  page_id_t root_page_id_{INVALID_PAGE_ID};
  BufferPoolManager *buffer_pool_manager_;
  KeyManager processor_;
  int leaf_max_size_;
  int internal_max_size_;
};
```

`BPlusTree`类是B+树的主要实现类，其中包含了B+树的增删改查等操作。

该类中的`index_id_`与`root_page_id_`分别表示索引的id和根节点的id。根节点的id放在`Index_Roots_Page`上，这个数据页用于根据`index_id`查找对应的根节点id。而对于根节点的修改，需要调用`UpdateRootPageId`函数来对`root_id`进行修改。

1. 构造函数：初始化B+树的一些参数
```cpp
BPlusTree::BPlusTree(index_id_t index_id, BufferPoolManager *buffer_pool_manager, const KeyManager &KM,
                     int leaf_max_size, int internal_max_size)
    : index_id_(index_id),
      buffer_pool_manager_(buffer_pool_manager),
      processor_(KM),
      leaf_max_size_(leaf_max_size),
      internal_max_size_(internal_max_size) {

	if (leaf_max_size == UNDEFINED_SIZE) leaf_max_size_ = (PAGE_SIZE - LEAF_PAGE_HEADER_SIZE) / (processor_.GetKeySize() + sizeof(RowId)) - 1;
	if (internal_max_size == UNDEFINED_SIZE) internal_max_size_ = (PAGE_SIZE - INTERNAL_PAGE_HEADER_SIZE) / (processor_.GetKeySize() + sizeof(page_id_t)) - 1;

	
  auto root_page = reinterpret_cast<IndexRootsPage *>(buffer_pool_manager_->FetchPage(INDEX_ROOTS_PAGE_ID)->GetData());
  if (!root_page->GetRootId(index_id, &root_page_id_)) {
    root_page_id_ = INVALID_PAGE_ID;
  }
	buffer_pool_manager_->UnpinPage(INDEX_ROOTS_PAGE_ID, false);
}
```
注意，如果传入的`leaf_max_size`和`internal_max_size`是默认值0，即`UNDEFINED_SIZE`，那么需要自己根据`keysize`进行计算

构造的时候，我们会先去`Index_Roots_Page`中查找对应的`root_page_id_`，如果没有找到，那么`root_page_id_`就是`INVALID_PAGE_ID`（代表空树）。这样可以避免重复创建B+树。


2. 查找操作：`GetValue`函数，根据key查找对应的value
```cpp
bool BPlusTree::GetValue(const GenericKey *key, std::vector<RowId> &result, Txn *transaction) {
  if (IsEmpty()) {
    return false;
  }
  auto leaf = reinterpret_cast<BPlusTreeLeafPage *>(FindLeafPage(key, root_page_id_, false)->GetData());
  if (leaf == nullptr) {
    LOG(ERROR) << "GetValue() : Can't find leaf page";
    return false;
  }
  RowId rid;
  if (leaf->Lookup(key, rid, processor_)) {
    result.push_back(rid);
    buffer_pool_manager_->UnpinPage(leaf->GetPageId(), false);
    return true;
  }
  buffer_pool_manager_->UnpinPage(leaf->GetPageId(), false);
  return false;
}
```
该函数首先调用了`FindLeafPage`函数找到对应的叶子页，然后调用叶子页的`Lookup`函数查找key对应的value。

`FindLeafPage`函数的实现如下：
```cpp
Page *BPlusTree::FindLeafPage(const GenericKey *key, page_id_t page_id, bool leftMost) {
  if (page_id == INVALID_PAGE_ID) page_id = root_page_id_; //默认从根节点开始查找
  auto page = reinterpret_cast<BPlusTreePage *>(buffer_pool_manager_->FetchPage(page_id)->GetData());
  while (!page->IsLeafPage()) {
    auto internal = reinterpret_cast<InternalPage *>(page);
    page_id_t child_page_id;
    if (leftMost) {
      child_page_id = internal->ValueAt(0);
    } else {
      child_page_id = internal->Lookup(key, processor_);
    }
    auto child_page = reinterpret_cast<BPlusTreePage *>(buffer_pool_manager_->FetchPage(child_page_id)->GetData());
    //LOG(INFO) << "[FindLeafPage] Internal page: " << page->GetPageId() << endl;
    buffer_pool_manager_->UnpinPage(page->GetPageId(), false);
    page = child_page;
  }
  return reinterpret_cast<Page *>(page);
}
```
`page`与`child_page`交替进行，直到找到叶子页为止。

3. 插入操作：`Insert`函数，插入key-value键值对
```cpp
bool BPlusTree::Insert(GenericKey *key, const RowId &value, Txn *transaction) {
  if (IsEmpty()) {
    //LOG(INFO) << "SB";
    StartNewTree(key, value);
    LOG(INFO) << "The tree is empty, and build the tree successfully";
    return true;
  } 
  else {
    //LOG(INFO) << "Insert into tree";
    return InsertIntoLeaf(key, value, transaction);
  }
}
```
如果B+树为空，那么直接调用`StartNewTree`函数创建新的树；否则调用`InsertIntoLeaf`函数插入键值对。

`StartNewTree`函数的实现如下：
```cpp
void BPlusTree::StartNewTree(GenericKey *key, const RowId &value) {
  auto *page = buffer_pool_manager_->NewPage(root_page_id_); //新分配一个页，得到了root_page_id_

  if (page == nullptr) {
    LOG(ERROR) << "No newpage build";
  }
  auto *root = reinterpret_cast<LeafPage *>(page->GetData());
  UpdateRootPageId(1); //新建b+树，应该把root_page_id_ 插入 到header_page
  root->Init(root_page_id_, INVALID_PAGE_ID, processor_.GetKeySize(), leaf_max_size_);  //todo
  root->Insert(key, value, processor_);
  buffer_pool_manager_->UnpinPage(root->GetPageId(), true);
} 
```

`InsertIntoLeaf`函数的实现如下：
```cpp
bool BPlusTree::InsertIntoLeaf(GenericKey *key, const RowId &value, Txn *transaction) {
  // find leaf
  auto *leaf_page = FindLeafPage(key, INVALID_PAGE_ID, false);
  if(leaf_page == nullptr) LOG(INFO) << "Not find leaf page";
  auto *leaf = reinterpret_cast<BPlusTreeLeafPage *>(leaf_page->GetData());
  RowId rid;
  if (leaf->Lookup(key, rid, processor_)) { // key已经存在
    LOG(ERROR) << "Key already exists";
    buffer_pool_manager_->UnpinPage(leaf->GetPageId(), false);  // leafpage需要被unpin
    return false; //只支持unique key
  }

  if (leaf->GetSize() < leaf->GetMaxSize()) { // leafpage未满，简单插入
    leaf->Insert(key, value, processor_);
    buffer_pool_manager_->UnpinPage(leaf->GetPageId(), true);
    return true;
  } 

  //LOG(WARNING) << "Need to split the leaf page";
  leaf->Insert(key, value, processor_); //先插入，再split，此时有maxsize+1个元素
  auto *new_leaf = Split(leaf, transaction);

  new_leaf->SetNextPageId(leaf->GetNextPageId());
  leaf->SetNextPageId(new_leaf->GetPageId());

  InsertIntoParent(leaf, new_leaf->KeyAt(0), new_leaf, transaction);

  buffer_pool_manager_->UnpinPage(leaf->GetPageId(), true);
  buffer_pool_manager_->UnpinPage(new_leaf->GetPageId(), true);

  return true;
}
```
先解决叶子层能解决的情况，解决不掉的丢给父节点处理。

`InsertIntoParent`函数的实现如下：
```cpp
void BPlusTree::InsertIntoParent(BPlusTreePage *old_node, GenericKey *key, BPlusTreePage *new_node, Txn *transaction) {
  if (old_node->IsRootPage()) {
    auto *page = buffer_pool_manager_->NewPage(root_page_id_);
    if (page != nullptr) {
      UpdateRootPageId(0); //如果老节点是根节点，那么需要建立新的根节点
      auto *root = reinterpret_cast<InternalPage *>(page->GetData());
      root->Init(root_page_id_, INVALID_PAGE_ID, processor_.GetKeySize(), internal_max_size_);
      root->PopulateNewRoot(old_node->GetPageId(), key, new_node->GetPageId());

      old_node->SetParentPageId(root_page_id_);
      new_node->SetParentPageId(root_page_id_);

      buffer_pool_manager_->UnpinPage(root->GetPageId(), true);

      buffer_pool_manager_->UnpinPage(old_node->GetPageId(), true);
      buffer_pool_manager_->UnpinPage(new_node->GetPageId(), true);
      return;
    }
  }
  else // old_node不是根节点
  {
    auto *page = buffer_pool_manager_->FetchPage(old_node->GetParentPageId()); //get the existing parent page
    if (page != nullptr) {
      auto *parent = reinterpret_cast<BPlusTreeInternalPage *>(page->GetData());
      if (parent->GetSize() < parent->GetMaxSize()) { //简单情况，直接插入
        parent->InsertNodeAfter(old_node->GetPageId(), key, new_node->GetPageId());
        new_node->SetParentPageId(parent->GetPageId());

        buffer_pool_manager_->UnpinPage(parent->GetPageId(), true);

        buffer_pool_manager_->UnpinPage(old_node->GetPageId(), true);
        buffer_pool_manager_->UnpinPage(new_node->GetPageId(), true);
        return;
      } else { // parent page is full
        //先插入，再split，此时有maxsize+1个元素
        parent->InsertNodeAfter(old_node->GetPageId(), key, new_node->GetPageId());
        auto *new_parent = Split(parent, transaction); //到这里，parent已经被split了，并且对孩子们都处理完成了
        //接下来要处理parent的parent
        InsertIntoParent(parent, new_parent->KeyAt(0), new_parent, transaction);
        
        buffer_pool_manager_->UnpinPage(new_parent->GetPageId(), true);

        buffer_pool_manager_->UnpinPage(parent->GetPageId(), true);


        buffer_pool_manager_->UnpinPage(old_node->GetPageId(), true);
        buffer_pool_manager_->UnpinPage(new_node->GetPageId(), true);
      }
    }
  }
}
```

4. 删除操作：`Remove`函数，删除key对应的键值对
```cpp
void BPlusTree::Remove(const GenericKey *key, Txn *transaction) {
  if (IsEmpty()) {
    return;
  }
  auto *leaf = reinterpret_cast<BPlusTreeLeafPage *>(FindLeafPage(key, INVALID_PAGE_ID, false)->GetData());
  if (leaf == nullptr) {
    LOG(ERROR) << "BPlusTree::Remove(const GenericKey *key, Txn *transaction): " << "FindLeafPage Error";
    return;
  } 
  if (leaf->GetSize() > leaf->GetMinSize()) {
    leaf->RemoveAndDeleteRecord(key, processor_);
    buffer_pool_manager_->UnpinPage(leaf->GetPageId(), true);
    return;
  } 
  // leaf page size <= min size
  //LOG(WARNING) << "Need to CoalesceOrRedistribute";
  leaf->RemoveAndDeleteRecord(key, processor_);
  //先删除，再CoalesceOrRedistribute，此时有minsize-1个元素
  CoalesceOrRedistribute(leaf, transaction); 
  buffer_pool_manager_->UnpinPage(leaf->GetPageId(), true); 
  
} 
```

`CoalesceOrRedistribute`函数的实现如下：
```cpp
template <typename N>
bool BPlusTree::CoalesceOrRedistribute(N *&node, Txn *transaction) {
  if (node->IsRootPage()) { //根节点，需要调整根节点
    bool deleted = AdjustRoot(node);
    buffer_pool_manager_->UnpinPage(node->GetPageId(), true);
    return deleted;
  }

  auto *parent = reinterpret_cast<InternalPage *>(buffer_pool_manager_->FetchPage(node->GetParentPageId())->GetData());
  int index = parent->ValueIndex(node->GetPageId());
  //先找到node在parent中的位置，并且确定neighbor
  page_id_t neighbor_page_id;
  if (index == 0) {
    neighbor_page_id = parent->ValueAt(1);
  } else {
    neighbor_page_id = parent->ValueAt(index - 1); 
  }

  auto *neighbor = reinterpret_cast<N *>(buffer_pool_manager_->FetchPage(neighbor_page_id)->GetData());

  if (neighbor->GetSize() + node->GetSize() > node->GetMaxSize()) {
    Redistribute(neighbor, node, index);
    buffer_pool_manager_->UnpinPage(neighbor->GetPageId(), true);
    buffer_pool_manager_->UnpinPage(parent->GetPageId(), false);
    buffer_pool_manager_->UnpinPage(node->GetPageId(), true);
    return false;
  } else {
    Coalesce(neighbor, node, parent, index, transaction);
    buffer_pool_manager_->UnpinPage(parent->GetPageId(), true);
    buffer_pool_manager_->UnpinPage(neighbor->GetPageId(), true);
    buffer_pool_manager_->UnpinPage(node->GetPageId(), true);
    return true;
  }
  
}
```
If sibling's size + input page's size > page's max size, then redistribute. Otherwise, merge.

`Coalesce`函数的实现如下：
```cpp
bool BPlusTree::Coalesce(InternalPage *&neighbor_node, InternalPage *&node, InternalPage *&parent, int index,
                         Txn *transaction) {
  if (index == 0) {
    // Move all entries from the node to the neighbor node
    neighbor_node->MoveAllTo(node, parent->KeyAt(1), buffer_pool_manager_);
    // Unpin the neighbor node
    buffer_pool_manager_->UnpinPage(neighbor_node->GetPageId(), true);
    // Remove the entry for the node from the parent
    parent->Remove(1);
  } else {
    node->MoveAllTo(neighbor_node, parent->KeyAt(index), buffer_pool_manager_);
    buffer_pool_manager_->UnpinPage(neighbor_node->GetPageId(), true);
    parent->Remove(index);
  }

  buffer_pool_manager_->UnpinPage(node->GetPageId(), true);
  // If the parent node is underfull after the removal, coalesce or redistribute it
  return CoalesceOrRedistribute(parent, transaction);
}
```
合并的时候，要把parent里面的middle_key也一起移动到neighbor中。以维持有序性，合并完成后把parent的middle_key删除。
由于合并后，parent的size可能小于minsize，所以要递归调用`CoalesceOrRedistribute`函数，来处理parent。

`Redistribute`函数的实现如下：
```cpp
void BPlusTree::Redistribute(InternalPage *neighbor_node, InternalPage *node, int index) {
  auto parent = reinterpret_cast<InternalPage *>(buffer_pool_manager_->FetchPage(node->GetParentPageId())->GetData());
  if (index == 0) {
    // move neighbor_node's first key & value pair into end of node
    neighbor_node->MoveFirstToEndOf(node, parent->KeyAt(1), buffer_pool_manager_);
    parent->SetKeyAt(1, neighbor_node->KeyAt(0));
  } else {
    // move neighbor_node's last key & value pair into head of node
    neighbor_node->MoveLastToFrontOf(node, parent->KeyAt(index), buffer_pool_manager_);
    parent->SetKeyAt(index, node->KeyAt(0));
  }
  buffer_pool_manager_->UnpinPage(parent->GetPageId(), true);
  buffer_pool_manager_->UnpinPage(neighbor_node->GetPageId(), true);
  buffer_pool_manager_->UnpinPage(node->GetPageId(), true);
}
```
Redistribute的时候，要把parent中的middle_key更新为neighbor中的middle_key，以维持有序性。

neighbor中的0号，是原来移动前的1号，他应该给父亲，父亲的mid给到node中。他现在为0号就相当于在neighbor里删掉了

Redistribute的时候，不需要递归调用`CoalesceOrRedistribute`函数，因为neighbor的size是大于minsize的，不会导致parent的size小于minsize。

5. 释放操作：`Destroy`函数，销毁B+树
```cpp
void BPlusTree::Destroy(page_id_t current_page_id) {  
  if (IsEmpty()) return;
  if (current_page_id == INVALID_PAGE_ID) {
    current_page_id = root_page_id_;
    root_page_id_ = INVALID_PAGE_ID;
    UpdateRootPageId(2); //删除根节点
  }
  auto page = reinterpret_cast<BPlusTreePage *>(buffer_pool_manager_->FetchPage(current_page_id)->GetData());
  if (!page->IsLeafPage()) {
    auto internal = reinterpret_cast<InternalPage *>(page);
    for (int i = 0; i < internal->GetSize(); i++) {
      Destroy(internal->ValueAt(i));
    }
  }
  buffer_pool_manager_->DeletePage(current_page_id);
  buffer_pool_manager_->UnpinPage(current_page_id, false);
}
```
递归删除所有的节点


6. `INDEX ITERATOR`
```cpp
IndexIterator BPlusTree::Begin() { 
  //return IndexIterator(); 
  auto page = FindLeafPage(nullptr, root_page_id_, true); //find the left most leaf page
  auto leaf = reinterpret_cast<BPlusTreeLeafPage *>(page->GetData());
  page_id_t page_id = leaf->GetPageId();
  buffer_pool_manager_->UnpinPage(page_id, false);
  return IndexIterator(page_id, buffer_pool_manager_, 0);
}
```

```cpp
IndexIterator BPlusTree::Begin(const GenericKey *key) { 
  //return IndexIterator(); 
  auto page = FindLeafPage(key, root_page_id_, false); //find the leaf page that contains the input key
  auto leaf = reinterpret_cast<BPlusTreeLeafPage *>(page->GetData());
  page_id_t page_id = leaf->GetPageId();
  int index = leaf->KeyIndex(key, processor_);
  buffer_pool_manager_->UnpinPage(page_id, false);
  return IndexIterator(page_id, buffer_pool_manager_, index);
}
```

```cpp
IndexIterator BPlusTree::End() { 
  //return IndexIterator(); 
  
  auto page = FindLeafPage(nullptr, root_page_id_, true); //find the left most leaf page
  auto leaf = reinterpret_cast<BPlusTreeLeafPage *>(page->GetData());
  page_id_t page_id = leaf->GetPageId();
  page_id_t next_page_id = leaf->GetNextPageId();
  while (next_page_id != INVALID_PAGE_ID) {
    buffer_pool_manager_->UnpinPage(page_id, false);
    page = buffer_pool_manager_->FetchPage(next_page_id);
    leaf = reinterpret_cast<BPlusTreeLeafPage *>(page->GetData());
    page_id = leaf->GetPageId();
    next_page_id = leaf->GetNextPageId();
  }
  buffer_pool_manager_->UnpinPage(page_id, false);
  //LOG(INFO) << "End() : page_id = " << page_id << std::endl;
  return IndexIterator(page_id, buffer_pool_manager_, leaf->GetSize() - 1);

}
```

### B+树索引迭代器
```cpp
class IndexIterator {
  using LeafPage = BPlusTreeLeafPage;

 public:
  // you may define your own constructor based on your member variables
  explicit IndexIterator();

  explicit IndexIterator(page_id_t page_id, BufferPoolManager *bpm, int index = 0);

  ~IndexIterator();

  /** Return the key/value pair this iterator is currently pointing at. */
  std::pair<GenericKey *, RowId> operator*();

  /** Move to the next key/value pair.*/
  IndexIterator &operator++();

  /** Return whether two iterators are equal */
  bool operator==(const IndexIterator &itr) const;

  /** Return whether two iterators are not equal. */
  bool operator!=(const IndexIterator &itr) const;

 private:
  page_id_t current_page_id{INVALID_PAGE_ID};
  LeafPage *page{nullptr};
  int item_index{0};
  BufferPoolManager *buffer_pool_manager{nullptr};
  // add your own private member variables here
};
```

```cpp
IndexIterator &IndexIterator::operator++() {
  // Increase the current item index
  ++item_index;

  // Check if we need to move to the next page
  if (item_index >= page->GetSize()) {
    page_id_t next_page_id = page->GetNextPageId();
    
    // If there is a next page
    if (next_page_id != INVALID_PAGE_ID) {
      // Unpin the current page
      buffer_pool_manager->UnpinPage(current_page_id, false);
      
      // Move to the next page
      current_page_id = next_page_id;
      auto *next_page = buffer_pool_manager->FetchPage(next_page_id);
      
      // If the next page is not null
      if (next_page != nullptr) {
        // Cast the data to a LeafPage pointer
        auto *next_leaf_page = reinterpret_cast<LeafPage *>(next_page->GetData());
        
        // Update the page pointer and reset the item index
        page = next_leaf_page;
        item_index = 0;
      }
    } else {
      // If there is no next page, set the iterator to its default state
      buffer_pool_manager->UnpinPage(current_page_id, false);
      current_page_id = INVALID_PAGE_ID;
      page = nullptr;
      item_index = 0;
      *this = IndexIterator(); //把调用对象置为默认状态
    }
  }

  return *this;
}
```

## 5. 测试
###  b_plus_tree_test
![](img/MiniSQL%20个人报告-杨正宇-3220104117/20240609181122.png)
将n改成10000，顺利通过测试，说明b+树的实现是正确的。

### b_plus_tree_index_test
![](img/MiniSQL%20个人报告-杨正宇-3220104117/20240609181347.png)
测试通过，说明索引的实现是正确的。

### index_iterator_test
![](img/MiniSQL%20个人报告-杨正宇-3220104117/20240609181427.png)
测试通过，说明迭代器的实现是正确的。

## 6. 总结
这个模块还是非常有挑战性的，我也花了不少时间进行调试。在实现B+树的过程中，我对B+树的结构有了更深入的了解，也对B+树的插入、删除、查找等操作有了更深入的理解。同时，我也学会了如何使用迭代器来遍历B+树的所有元素。这个模块的实现对于后续的查询优化和索引优化是非常重要的，也是数据库系统中的一个重要组成部分。

在测试的时候，也发现了一些前面模块遇到的问题，和前面的同学经过沟通合作也顺利解决掉了这些问题。这次任务锻炼了我的工程能力，让我对多文件的项目有了自顶向下的分析设计能力。



![](img/MiniSQL%20个人报告-杨正宇-3220104117/20240609182857.png)

![](img/MiniSQL%20个人报告-杨正宇-3220104117/20240609183005.png)

![](img/MiniSQL%20个人报告-杨正宇-3220104117/20240609183030.png)

![](img/MiniSQL%20个人报告-杨正宇-3220104117/20240609183326.png)

3. 考察SQL执行以及数据插入操作：
  a. 执行数据库文件sql.txt，向表中插入$100000$条记录（分$10$次插入，每次插入$10000$条，至少插入$30000$条）
    ⅰ. 参考SQL数据，由脚本自动生成：
    ⅱ. 批量执行时，所有sql执行完显示总的执行时间
  b. 执行全表扫描select * from account，验证插入的数据是否正确（要求输出查询到$100000$条记录）
4. 考察点查询操作：
  a. select * from account where id = ?
  b. select * from account where balance = ?
  c. select * from account where name = "name56789"，此处记录执行时间$t_1$
  d. select * from account where id <> 12599999；
  ![](img/MiniSQL%20个人报告-杨正宇-3220104117/20240609183435.png)
  e. select * from account where balance <> 449.160004；
  ![](img/MiniSQL%20个人报告-杨正宇-3220104117/20240609183642.png)
  12599998条没了
  f. select * from account where name <> "name99997";
  ![](img/MiniSQL%20个人报告-杨正宇-3220104117/20240609183735.png)
5. 考察多条件查询与投影操作：
  a. select id, name from account where balance >= 200 and balance < 400;
  ![](img/MiniSQL%20个人报告-杨正宇-3220104117/20240609183802.png)
  b. select name, balance from account where balance > 200 and id <= 12533333;
  ![](img/MiniSQL%20个人报告-杨正宇-3220104117/20240609183910.png)
  c. select * from account where id < 12515000 and name > "name14500";
  ![](img/MiniSQL%20个人报告-杨正宇-3220104117/20240609183949.png)
  d. select * from account where id < 12500200 and name < "name00100"，此处记录执行时间$t_5$
  ![](img/MiniSQL%20个人报告-杨正宇-3220104117/20240609184030.png)
  $t_5$ = 0.0030 sec
6. 考察唯一约束：
  a. insert into account values(?, ?, ?)，提示PRIMARY KEY约束冲突或UNIQUE约束冲突
  ![](img/MiniSQL%20个人报告-杨正宇-3220104117/20240609184248.png)
7. 考察索引的创建删除操作、记录的删除操作以及索引的效果：
  a. create index idx01 on account(name);
  ![](img/MiniSQL%20个人报告-杨正宇-3220104117/20240609184706.png)
  b. select * from account where name = "name56789"，此处记录执行时间$t_2$，要求$t_2<t_1$
  ![](img/MiniSQL%20个人报告-杨正宇-3220104117/20240609185303.png)
  都非常快
  c. select * from account where name = "name45678"，此处记录执行时间$t_3$
  ![](img/MiniSQL%20个人报告-杨正宇-3220104117/20240609185339.png)
  $t_3$ = 0
  d. select * from account where id < 12500200 and name < "name00100"，此处记录执行时间$t_6$，比较$t_5$和$t_6$
  ![](img/MiniSQL%20个人报告-杨正宇-3220104117/20240609185714.png)
  e. delete from account where name = "name45678"
  ![](img/MiniSQL%20个人报告-杨正宇-3220104117/20240609185813.png)
  f. insert into account values(666666, "name45678", 11111);
  ![](img/MiniSQL%20个人报告-杨正宇-3220104117/20240609185906.png)
  g. drop index idx01
  h. 执行(c)的语句，此处记录执行时间$t_4$，要求$t_3<t_4$
1. 考察更新操作：
  a. update account set id = ?, balance = ? where name = "name56789";
 并通过select操作验证记录被更新
1. 考察删除操作：
  a. delete from account where balance = ?，并通过select操作验证记录被删除
  b. delete from account，并通过select操作验证全表被删除
  c. drop table account，并通过show tables验证该表被删除